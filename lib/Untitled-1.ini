import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // Import for TextInputFormatter
import 'dart:async';

// --- COLOR PALETTE (Approximated from the Figma design) ---
const Color kBackgroundColor = Color(0xFFF0F5F9); // Very light grey/blue for the scaffold
const Color kPrimaryBlue = Color(0xFF3F72AF); // Dark blue for headings and active indicators
const Color kSecondaryBlue = Color(0xFF5E9FFF); // Medium blue for buttons and accents
const Color kLightBlueGradient = Color(0xFFE3F2FD); // Lightest blue for card gradient
const Color kHeaderCurveBlue = Color(0xFF86c4f0); // The bright curved header blue
const Color kErrorRed = Color(0xFFE57373); // Red for 'Code invalid'
const Color kKeypadBackground = Color(0xFF4C4C4C); // Dark gray for keypad background
const Color kKeypadKeyColor = Color(0xFF6A6A6A); // Slightly lighter gray for keys
const Color kKeypadSpecialKeyColor = Color(0xFF3B3B3B); // Darker gray for special keys
const Color kProfileCircleBlue = Color(0xFFc4e1f7); // Light blue circle background

// =================================================================
// >>> 0. ALL DATA MODELS (DEFINED FIRST TO PREVENT TYPE ERRORS)
// =================================================================

class OnboardingPageData {
  final String title;
  final String description;
  final IconData icon;
  final bool isLastPage;

  OnboardingPageData({
    required this.title,
    required this.description,
    required this.icon,
    this.isLastPage = false,
  });
}

class ChatDataModel {
  final String id;
  final String name;
  final String lastMessage;
  final DateTime lastMessageTime;
  final String? avatarUrl;
  final int unreadCount;
  final bool isGroupChat;

  ChatDataModel({
    required this.id,
    required this.name,
    required this.lastMessage,
    required this.lastMessageTime,
    this.avatarUrl,
    this.unreadCount = 0,
    this.isGroupChat = false,
  });
}

class MessageModel {
  final String id;
  final String content;
  final DateTime timestamp;
  final bool isMe;

  MessageModel({
    required this.id,
    required this.content,
    required this.timestamp,
    required this.isMe,
  });
}

class ContactModel {
  final String id;
  final String name;
  final String phoneNumber;
  final String? avatarUrl;

  ContactModel({
    required this.id,
    required this.name,
    required this.phoneNumber,
    this.avatarUrl,
  });
}

// --- MAIN APPLICATION WIDGET ---
void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'E-Chat App',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        primaryColor: kPrimaryBlue,
        scaffoldBackgroundColor: kBackgroundColor,
        fontFamily: 'Inter',
        useMaterial3: true,
      ),
      initialRoute: '/',
      routes: {
        '/': (context) => const OnboardingScreen(),
        '/login': (context) => const LoginScreen(),
        '/otp': (context) => const OtpScreen(fullPhoneNumber: ''),
        '/register': (context) => const RegisterScreen(),
        '/registerOtp': (context) => const RegisterOtpScreen(fullPhoneNumber: ''),
        '/profileSetup': (context) => const ProfileSetupScreen(),
        '/pinSecurity': (context) => const PinSecurityScreen(),
        '/chatList': (context) => const ChatListScreen(),
        '/chatRoom': (context) => const Placeholder(),
        '/newGroup': (context) => const NewGroupScreen(), // New Group Route
      },
      onGenerateRoute: (settings) {
        if (settings.name == '/otp') {
          final fullPhoneNumber = settings.arguments as String? ?? '';
          return MaterialPageRoute(builder: (context) => OtpScreen(fullPhoneNumber: fullPhoneNumber));
        }
        if (settings.name == '/registerOtp') {
          final fullPhoneNumber = settings.arguments as String? ?? '';
          return MaterialPageRoute(builder: (context) => RegisterOtpScreen(fullPhoneNumber: fullPhoneNumber));
        }
        if (settings.name == '/chatRoom') {
          if (settings.arguments is ChatDataModel) {
            final chat = settings.arguments as ChatDataModel;
            return MaterialPageRoute(builder: (context) => ChatRoomScreen(chat: chat));
          }
          return MaterialPageRoute(builder: (context) => const ChatListScreen()); 
        }
        return null; 
      },
    );
  }
}

// =================================================================
// >>> 1. ONBOARDING FLOW SCREENS
// =================================================================

class OnboardingScreen extends StatefulWidget {
  const OnboardingScreen({super.key});

  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenState extends State<OnboardingScreen> {
  final PageController _pageController = PageController();
  int _currentPage = 0;

  final List<OnboardingPageData> pages = [
    OnboardingPageData(title: 'Group Chatting', description: 'Connect with multiple members in group chats. Instantly connect via text and voice.', icon: Icons.groups_2_outlined),
    OnboardingPageData(title: 'Video And Voice Calls', description: 'Instantly connect via video and voice calls. Talk to your friends and family easily.', icon: Icons.videocam_outlined),
    OnboardingPageData(title: 'Message Encryption', description: 'Ensure privacy with encrypted messages. Your conversations are safe and secure.', icon: Icons.lock_outline),
    OnboardingPageData(title: 'Cross-Platform Compatibility', description: 'Access chats on any device seamlessly. Never miss a message again.', icon: Icons.devices_outlined, isLastPage: true),
  ];

  @override
  void initState() {
    super.initState();
    _pageController.addListener(() {
      setState(() { _currentPage = _pageController.page?.round() ?? 0; });
    });
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  void _navigateToLogin() { Navigator.of(context).pushReplacementNamed('/login'); }
  void _nextPage() {
    if (_currentPage < pages.length - 1) {
      _pageController.nextPage(duration: const Duration(milliseconds: 400), curve: Curves.easeInOut);
    } else {
      _navigateToLogin();
    }
  }
  void _skipOnboarding() { _navigateToLogin(); }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            Expanded(
              child: PageView.builder(
                controller: _pageController,
                itemCount: pages.length,
                itemBuilder: (context, index) => OnboardingPage(data: pages[index], onButtonPressed: _navigateToLogin),
              ),
            ),
            _buildBottomNavigation(context),
          ],
        ),
      ),
    );
  }

  Widget _buildBottomNavigation(BuildContext context) {
    final bool isLastPage = pages[_currentPage].isLastPage;
    return Container(
      height: 70,
      color: kBackgroundColor,
      padding: const EdgeInsets.symmetric(horizontal: 25.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          GestureDetector(
            onTap: _skipOnboarding,
            child: Text('Skip', style: TextStyle(color: isLastPage ? Colors.transparent : Colors.grey, fontSize: 16)),
          ),
          Row(
            children: List.generate(pages.length, (index) => AnimatedContainer(
              duration: const Duration(milliseconds: 300),
              margin: const EdgeInsets.symmetric(horizontal: 4.0),
              height: 8, width: 8,
              decoration: BoxDecoration(color: _currentPage == index ? kPrimaryBlue : Colors.grey.shade300, borderRadius: BorderRadius.circular(4)),
            )),
          ),
          GestureDetector(
            onTap: _nextPage,
            child: Text(isLastPage ? 'Finish' : 'Next', style: const TextStyle(color: kPrimaryBlue, fontSize: 16, fontWeight: FontWeight.w600)),
          ),
        ],
      ),
    );
  }
}

class OnboardingPage extends StatelessWidget {
  final OnboardingPageData data;
  final VoidCallback onButtonPressed;
  
  const OnboardingPage({super.key, required this.data, required this.onButtonPressed});

  @override
  Widget build(BuildContext context) {
    final bool showCardButton = data.title == 'Group Chatting';
    return Padding(
      padding: const EdgeInsets.all(30.0),
      child: Container(
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(20.0),
          boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.05), blurRadius: 15, offset: const Offset(0, 5))],
        ),
        child: Stack(
          children: [
            Positioned.fill(
              child: Container(
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(20.0),
                  gradient: LinearGradient(begin: Alignment.topCenter, end: Alignment.bottomCenter, colors: [Colors.white, Colors.white, kLightBlueGradient.withOpacity(0.5), kLightBlueGradient], stops: const [0.0, 0.6, 0.8, 1.0]),
                ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(24.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Expanded(
                    child: Center(
                      child: Container(
                        height: 200, width: 200,
                        decoration: BoxDecoration(color: kPrimaryBlue.withOpacity(0.1), borderRadius: BorderRadius.circular(100)),
                        child: Icon(data.icon, size: 100, color: kPrimaryBlue),
                      ),
                    ),
                  ),
                  Column(
                    children: [
                      Text(data.title, textAlign: TextAlign.center, style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: kPrimaryBlue)),
                      const SizedBox(height: 10),
                      Text(data.description, textAlign: TextAlign.center, style: TextStyle(fontSize: 14, color: Colors.grey.shade600, height: 1.4)),
                    ],
                  ),
                 
                  const SizedBox(height: 40),

                  if (showCardButton) _buildPrimaryButton(context),
                  if (!showCardButton) const SizedBox(height: 70),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPrimaryButton(BuildContext context) {
    return Container(
      width: double.infinity,
      height: 50,
      margin: const EdgeInsets.only(bottom: 20),
      child: ElevatedButton(
        onPressed: onButtonPressed,
        style: ElevatedButton.styleFrom(
          backgroundColor: kSecondaryBlue, foregroundColor: Colors.white,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(25.0)),
          elevation: 5,
        ),
        child: const Text('Get started', style: TextStyle(fontSize: 18, fontWeight: FontWeight.w600)),
      ),
    );
  }
}

// =================================================================
// >>> 2. AUTHENTICATION WIDGETS (Shared Helpers)
// =================================================================

Widget _buildAuthHeader({
  required BuildContext context,
  required String title,
  required String subTitle,
  required String actionButtonText,
  required VoidCallback onActionButtonPressed,
  bool showBackButton = false,
}) {
  final screenHeight = MediaQuery.of(context).size.height;
  const double headerHeightRatio = 0.40;
  final double headerHeight = screenHeight * headerHeightRatio;

  return ClipPath(
    clipper: LoginHeaderClipper(),
    child: Container(
      height: headerHeight,
      color: kHeaderCurveBlue,
      child: Padding(
        padding: const EdgeInsets.only(top: 50, left: 30, right: 30),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  children: [
                    if (showBackButton) 
                      BackButton(color: Colors.white, onPressed: () => Navigator.of(context).pop()),
                    if (showBackButton) const SizedBox(width: 8),
                    Text(title, style: const TextStyle(color: Colors.white, fontSize: 28, fontWeight: FontWeight.bold)),
                  ],
                ),
                SizedBox(
                  height: 40,
                  child: ElevatedButton(
                    onPressed: onActionButtonPressed,
                    style: ElevatedButton.styleFrom(backgroundColor: Colors.white, foregroundColor: kPrimaryBlue, padding: const EdgeInsets.symmetric(horizontal: 15), shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20))),
                    child: Text(actionButtonText, style: const TextStyle(fontWeight: FontWeight.bold)),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 30),
            Text(subTitle, style: const TextStyle(color: Colors.white, fontSize: 32, fontWeight: FontWeight.w500)),
          ],
        ),
      ),
    ),
  );
}

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final TextEditingController _phoneController = TextEditingController();
  String _countryCode = '+44'; 

  @override
  void initState() {
    super.initState();
    _phoneController.addListener(_checkAutoAdvance);
  }

  @override
  void dispose() {
    _phoneController.removeListener(_checkAutoAdvance);
    _phoneController.dispose();
    super.dispose();
  }

  void _checkAutoAdvance() {
    final cleanedText = _phoneController.text.replaceAll(' ', '');
    if (cleanedText.length == 10) {
      if (mounted) {
        _phoneController.removeListener(_checkAutoAdvance);
        _navigateToOtp();
      }
    } else {
      setState(() {});
    }
  }

  void _navigateToOtp() {
    final phoneNumber = _phoneController.text;
    final fullNumber = '$_countryCode ${phoneNumber.replaceAll(' ', '')}';
    Navigator.of(context).pushNamed('/otp', arguments: fullNumber); 
  }

  void _handleKeypadInput(String key) {
    String currentText = _phoneController.text;
    String cleanedText = currentText.replaceAll(' ', '');

    if (key == 'DEL') {
      if (currentText.isNotEmpty) {
        String rawText = currentText.replaceAll(' ', '');
        if (rawText.isNotEmpty) {
          rawText = rawText.substring(0, rawText.length - 1);
          final formattedValue = PhoneNumberFormatter().formatEditUpdate(
            TextEditingValue(text: currentText),
            TextEditingValue(text: rawText.padRight(10, '0').substring(0, rawText.length)),
          );
          _phoneController.value = formattedValue.copyWith(
            text: formattedValue.text.trim(),
            selection: TextSelection.collapsed(offset: formattedValue.text.trim().length),
          );
        }
      }
    } else if (key != '.' && cleanedText.length < 10) {
      String newRawText = cleanedText + key;
      
      final formattedValue = PhoneNumberFormatter().formatEditUpdate(
        TextEditingValue(text: currentText),
        TextEditingValue(text: newRawText),
      );

      _phoneController.value = formattedValue.copyWith(
        text: formattedValue.text,
        selection: TextSelection.collapsed(offset: formattedValue.text.length),
      );
    }
  }

  void _onCountryCodeChanged(String? newCode) {
    if (newCode != null) {
      setState(() { _countryCode = newCode; });
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    const double headerHeightRatio = 0.40;
    final double headerHeight = screenHeight * headerHeightRatio;
    const double overlap = 20;
    final double contentTop = headerHeight - overlap;
    final double keypadHeight = screenHeight * 0.35; 
    final bool enableNextButton = _phoneController.text.replaceAll(' ', '').length == 10;

    return Scaffold(
      body: Stack(
        children: [
          _buildAuthHeader(context: context, title: 'Login', subTitle: 'Enter your \nmobile phone', actionButtonText: 'Register', onActionButtonPressed: () => Navigator.of(context).pushReplacementNamed('/register')),
          Positioned(
            top: contentTop, left: 0, right: 0, bottom: keypadHeight, 
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 30.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text('You will get a code via sms.', style: TextStyle(color: Colors.grey, fontSize: 16)),
                  const SizedBox(height: 20),
                  _buildPhoneInputField(controller: _phoneController, countryCode: _countryCode, onCountryCodeChanged: _onCountryCodeChanged), 
                  const SizedBox(height: 20),
                  _buildRememberMeAndNextButton(context: context, onNextPressed: _navigateToOtp, enableNextButton: enableNextButton),
                ],
              ),
            ),
          ),
          Align(
            alignment: Alignment.bottomCenter,
            child: CustomKeypad(onKeyPress: _handleKeypadInput, isOtpMode: false),
          ),
        ],
      ),
    );
  }
}

class OtpScreen extends StatefulWidget {
  final String fullPhoneNumber;
  const OtpScreen({super.key, required this.fullPhoneNumber});
  @override
  State<OtpScreen> createState() => _OtpScreenState();
}

class _OtpScreenState extends State<OtpScreen> {
  final int _start = 60; 
  late int _current = _start;
  late Timer _timer;
  bool _isResendActive = false;
  final int _otpLength = 4;

  late List<TextEditingController> _otpControllers;
  late List<FocusNode> _otpFocusNodes;
  String _errorMessage = ''; 

  @override
  void initState() {
    super.initState();
    _otpControllers = List.generate(_otpLength, (_) => TextEditingController());
    _otpFocusNodes = List.generate(_otpLength, (_) => FocusNode());
    _startTimer();
  }

  @override
  void dispose() {
    _timer.cancel();
    for (var controller in _otpControllers) { controller.dispose(); }
    for (var focusNode in _otpFocusNodes) { focusNode.dispose(); }
    super.dispose();
  }

  void _startTimer() {
    _isResendActive = false;
    _current = _start;
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_current == 0) {
        setState(() { _timer.cancel(); _isResendActive = true; });
      } else {
        setState(() { _current--; });
      }
    });
  }

  void _onResendCode() { setState(() { _errorMessage = ''; }); _startTimer(); }
  
  void _handleKeypadInput(String key) {
    if (key == 'DEL') {
      for (int i = _otpLength - 1; i >= 0; i--) {
        if (_otpControllers[i].text.isNotEmpty) {
          _otpControllers[i].clear();
          FocusScope.of(context).requestFocus(_otpFocusNodes[i]); 
          break;
        } else if (i > 0) {
          FocusScope.of(context).requestFocus(_otpFocusNodes[i - 1]);
          break;
        }
      }
    } else if (key != '.') {
      for (int i = 0; i < _otpLength; i++) {
        if (_otpControllers[i].text.isEmpty) {
          _otpControllers[i].text = key;
          
          if (i < _otpLength - 1) {
            FocusScope.of(context).requestFocus(_otpFocusNodes[i + 1]);
          } else {
            FocusScope.of(context).unfocus();
            _onNextPressed();
          }
          break;
        }
      }
    }
  }

  void _onNextPressed() {
    String enteredOtp = _otpControllers.map((c) => c.text).join();
    
    if (enteredOtp.length == _otpLength) { 
      setState(() { _errorMessage = ''; });
      Navigator.of(context).pushNamedAndRemoveUntil('/chatList', (route) => false);
      debugPrint('Login OTP Verified. Navigating to Chat List.');
    } else {
      setState(() { _errorMessage = 'Code invalid'; });
    }
  }

  Widget _buildOtpFields() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: List.generate(_otpLength, (index) {
        return SizedBox(
          width: 50,
          child: TextField(
            controller: _otpControllers[index],
            focusNode: _otpFocusNodes[index],
            textAlign: TextAlign.center,
            keyboardType: TextInputType.none, 
            readOnly: true, 
            maxLength: 1,
            style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            cursorColor: kPrimaryBlue,
            decoration: InputDecoration(
              counterText: '',
              contentPadding: const EdgeInsets.symmetric(vertical: 10),
              enabledBorder: UnderlineInputBorder(borderSide: BorderSide(color: Colors.grey.shade400, width: 2)),
              focusedBorder: const UnderlineInputBorder(borderSide: BorderSide(color: kPrimaryBlue, width: 2)),
              errorText: null,
            ),
            onChanged: (value) {}, 
          ),
        );
      }),
    );
  }

  Widget _buildTimerAndResend() {
    final String timerText = _current > 0 ? '00:${_current.toString().padLeft(2, '0')}' : '00:00';
    
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(timerText),
        const SizedBox(width: 8),
        GestureDetector(
          onTap: _isResendActive ? _onResendCode : null,
          child: Text('Resend Code', style: TextStyle(color: _isResendActive ? kPrimaryBlue : Colors.grey, fontWeight: FontWeight.w600, decoration: TextDecoration.underline)),
        ),
      ],
    );
  }

  Widget _buildNextButton(BuildContext context) {
    bool enableNext = _otpControllers.every((c) => c.text.isNotEmpty);
    
    return Container(
      width: 50, height: 50,
      decoration: BoxDecoration(
        color: enableNext ? kSecondaryBlue : Colors.grey,
        shape: BoxShape.circle,
        boxShadow: enableNext ? [BoxShadow(color: kSecondaryBlue.withOpacity(0.5), blurRadius: 10, offset: const Offset(0, 5))] : null,
      ),
      child: IconButton(icon: const Icon(Icons.arrow_forward, color: Colors.white), onPressed: enableNext ? _onNextPressed : null),
    );
  }

  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    const double headerHeightRatio = 0.40;
    final double headerHeight = screenHeight * headerHeightRatio;
    const double overlap = 20;
    final double contentTop = headerHeight - overlap;
    final double keypadHeight = screenHeight * 0.35;
    
    final subTitle = 'Enter OTP Code\nSent to: ${widget.fullPhoneNumber}';

    return Scaffold(
      body: Stack(
        children: [
          _buildAuthHeader(context: context, title: 'Login', subTitle: subTitle, actionButtonText: 'Register', onActionButtonPressed: () => Navigator.of(context).pushReplacementNamed('/register'), showBackButton: true),
          Positioned(
            top: contentTop, left: 0, right: 0, bottom: keypadHeight, 
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 30.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const SizedBox(height: 20),
                   _buildTimerAndResend(),
                  const SizedBox(height: 30),
                   _buildOtpFields(),
                   if (_errorMessage.isNotEmpty)
                      Padding(padding: const EdgeInsets.only(top: 8.0), child: Text(_errorMessage, style: const TextStyle(color: kErrorRed, fontWeight: FontWeight.w500))),
                   Align(alignment: Alignment.centerRight, child: _buildNextButton(context)),
                  const SizedBox(height: 30),
                ],
              ),
            ),
          ),
          Align(
            alignment: Alignment.bottomCenter,
            child: CustomKeypad(onKeyPress: _handleKeypadInput, isOtpMode: true),
          ),
        ],
      ),
    );
  }
}

class RegisterScreen extends StatefulWidget {
  const RegisterScreen({super.key});
  @override
  State<RegisterScreen> createState() => _RegisterScreenState();
}

class _RegisterScreenState extends State<RegisterScreen> {
  final TextEditingController _phoneController = TextEditingController();
  String _countryCode = '+44'; 

  @override
  void initState() {
    super.initState();
    _phoneController.addListener(_checkAutoAdvance);
  }

  @override
  void dispose() {
    _phoneController.removeListener(_checkAutoAdvance);
    _phoneController.dispose();
    super.dispose();
  }

  void _checkAutoAdvance() {
    final cleanedText = _phoneController.text.replaceAll(' ', '');
    if (cleanedText.length == 10) {
      if (mounted) {
        _phoneController.removeListener(_checkAutoAdvance);
        _navigateToOtp();
      }
    } else {
      setState(() {});
    }
  }

  void _navigateToOtp() {
    final phoneNumber = _phoneController.text;
    final fullNumber = '$_countryCode ${phoneNumber.replaceAll(' ', '')}';
    Navigator.of(context).pushNamed('/registerOtp', arguments: fullNumber); 
  }

  void _handleKeypadInput(String key) {
    String currentText = _phoneController.text;
    String cleanedText = currentText.replaceAll(' ', '');

    if (key == 'DEL') {
      if (currentText.isNotEmpty) {
        String rawText = currentText.replaceAll(' ', '');
        if (rawText.isNotEmpty) {
          rawText = rawText.substring(0, rawText.length - 1);
          final formattedValue = PhoneNumberFormatter().formatEditUpdate(
            TextEditingValue(text: currentText),
            TextEditingValue(text: rawText.padRight(10, '0').substring(0, rawText.length)),
          );
          _phoneController.value = formattedValue.copyWith(
            text: formattedValue.text.trim(),
            selection: TextSelection.collapsed(offset: formattedValue.text.trim().length),
          );
        }
      }
    } else if (key != '.' && cleanedText.length < 10) {
      String newRawText = cleanedText + key;
      
      final formattedValue = PhoneNumberFormatter().formatEditUpdate(
        TextEditingValue(text: currentText),
        TextEditingValue(text: newRawText),
      );

      _phoneController.value = formattedValue.copyWith(
        text: formattedValue.text,
        selection: TextSelection.collapsed(offset: formattedValue.text.length),
      );
    }
  }
  void _onCountryCodeChanged(String? newCode) {
    if (newCode != null) {
      setState(() { _countryCode = newCode; });
    }
  }
  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    const double headerHeightRatio = 0.40;
    final double headerHeight = screenHeight * headerHeightRatio;
    const double overlap = 20;
    final double contentTop = headerHeight - overlap;
    final double keypadHeight = screenHeight * 0.35;
    final bool enableNextButton = _phoneController.text.replaceAll(' ', '').length == 10;

    return Scaffold(
      body: Stack(
        children: [
          _buildAuthHeader(context: context, title: 'Register', subTitle: 'Enter your \nmobile phone', actionButtonText: 'Login', onActionButtonPressed: () => Navigator.of(context).pushReplacementNamed('/login')),
          Positioned(
            top: contentTop, left: 0, right: 0, bottom: keypadHeight,
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 30.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text('You will get a code via sms.', style: TextStyle(color: Colors.grey, fontSize: 16)),
                  const SizedBox(height: 20),
                  _buildPhoneInputField(controller: _phoneController, countryCode: _countryCode, onCountryCodeChanged: _onCountryCodeChanged), 
                  const SizedBox(height: 20),
                  _buildRememberMeAndNextButton(context: context, onNextPressed: _navigateToOtp, enableNextButton: enableNextButton),
                ],
              ),
            ),
          ),
          Align(
            alignment: Alignment.bottomCenter,
            child: CustomKeypad(onKeyPress: _handleKeypadInput, isOtpMode: false),
          ),
        ],
      ),
    );
  }
}

class RegisterOtpScreen extends StatefulWidget {
  final String fullPhoneNumber;
  const RegisterOtpScreen({super.key, required this.fullPhoneNumber});
  @override
  State<RegisterOtpScreen> createState() => _RegisterOtpScreenState();
}

class _RegisterOtpScreenState extends State<RegisterOtpScreen> {
  final int _start = 60;
  late int _current = _start;
  late Timer _timer;
  bool _isResendActive = false;
  final int _otpLength = 4; 

  late List<TextEditingController> _otpControllers;
  late List<FocusNode> _otpFocusNodes;
  String _errorMessage = ''; 

  @override
  void initState() {
    super.initState();
    _otpControllers = List.generate(_otpLength, (_) => TextEditingController());
    _otpFocusNodes = List.generate(_otpLength, (_) => FocusNode());
    _startTimer();
  }

  @override
  void dispose() {
    _timer.cancel();
    for (var controller in _otpControllers) { controller.dispose(); }
    for (var focusNode in _otpFocusNodes) { focusNode.dispose(); }
    super.dispose();
  }

  void _startTimer() {
    _isResendActive = false;
    _current = _start;
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_current == 0) {
        setState(() { _timer.cancel(); _isResendActive = true; });
      } else {
        setState(() { _current--; });
      }
    });
  }

  void _onResendCode() { setState(() { _errorMessage = ''; }); _startTimer(); }
  
  void _handleKeypadInput(String key) {
    if (key == 'DEL') {
      for (int i = _otpLength - 1; i >= 0; i--) {
        if (_otpControllers[i].text.isNotEmpty) {
          _otpControllers[i].clear();
          FocusScope.of(context).requestFocus(_otpFocusNodes[i]); 
          break;
        } else if (i > 0) {
          FocusScope.of(context).requestFocus(_otpFocusNodes[i - 1]);
          break;
        }
      }
    } else if (key != '.') {
      for (int i = 0; i < _otpLength; i++) {
        if (_otpControllers[i].text.isEmpty) {
          _otpControllers[i].text = key;
          
          if (i < _otpLength - 1) {
            FocusScope.of(context).requestFocus(_otpFocusNodes[i + 1]);
          } else {
            FocusScope.of(context).unfocus();
            _onNextPressed();
          }
          break;
        }
      }
    }
  }

  void _onNextPressed() {
    String enteredOtp = _otpControllers.map((c) => c.text).join();
    
    if (enteredOtp.length == _otpLength) { 
      setState(() { _errorMessage = ''; });
      Navigator.of(context).pushNamed('/profileSetup'); 
      debugPrint('Registration OTP Verified. Navigating to Profile Setup.');
    } else {
      setState(() { _errorMessage = 'Code invalid'; });
    }
  }

  Widget _buildOtpFields() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: List.generate(_otpLength, (index) {
        return SizedBox(
          width: 50,
          child: TextField(
            controller: _otpControllers[index],
            focusNode: _otpFocusNodes[index],
            textAlign: TextAlign.center,
            keyboardType: TextInputType.none, 
            readOnly: true, 
            maxLength: 1,
            style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            cursorColor: kPrimaryBlue,
            decoration: InputDecoration(
              counterText: '',
              contentPadding: const EdgeInsets.symmetric(vertical: 10),
              enabledBorder: UnderlineInputBorder(borderSide: BorderSide(color: Colors.grey.shade400, width: 2)),
              focusedBorder: const UnderlineInputBorder(borderSide: BorderSide(color: kPrimaryBlue, width: 2)),
              errorText: null,
            ),
            onChanged: (value) {},
          ),
        );
      }),
    );
  }

  Widget _buildTimerAndResend() {
    final String timerText = _current > 0 ? '00:${_current.toString().padLeft(2, '0')}' : '00:00';
    
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(timerText),
        const SizedBox(width: 8),
        GestureDetector(
          onTap: _isResendActive ? _onResendCode : null,
          child: Text('Resend Code', style: TextStyle(color: _isResendActive ? kPrimaryBlue : Colors.grey, fontWeight: FontWeight.w600, decoration: TextDecoration.underline)),
        ),
      ],
    );
  }

  Widget _buildNextButton(BuildContext context) {
    bool enableNext = _otpControllers.every((c) => c.text.isNotEmpty);
    
    return Container(
      width: 50, height: 50,
      decoration: BoxDecoration(
        color: enableNext ? kSecondaryBlue : Colors.grey,
        shape: BoxShape.circle,
        boxShadow: enableNext ? [BoxShadow(color: kSecondaryBlue.withOpacity(0.5), blurRadius: 10, offset: const Offset(0, 5))] : null,
      ),
      child: IconButton(icon: const Icon(Icons.arrow_forward, color: Colors.white), onPressed: enableNext ? _onNextPressed : null),
    );
  }

  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    const double headerHeightRatio = 0.40;
    final double headerHeight = screenHeight * headerHeightRatio;
    const double overlap = 20;
    final double contentTop = headerHeight - overlap;
    final double keypadHeight = screenHeight * 0.35;
    
    final subTitle = 'Enter OTP Code\nSent to: ${widget.fullPhoneNumber}';

    return Scaffold(
      body: Stack(
        children: [
          _buildAuthHeader(context: context, title: 'Register', subTitle: subTitle, actionButtonText: 'Login', onActionButtonPressed: () => Navigator.of(context).pushReplacementNamed('/login'), showBackButton: true),
          Positioned(
            top: contentTop, left: 0, right: 0, bottom: keypadHeight, 
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 30.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const SizedBox(height: 20),
                   _buildTimerAndResend(),
                  const SizedBox(height: 30),
                   _buildOtpFields(),
                   if (_errorMessage.isNotEmpty)
                      Padding(padding: const EdgeInsets.only(top: 8.0), child: Text(_errorMessage, style: const TextStyle(color: kErrorRed, fontWeight: FontWeight.w500))),
                   Align(alignment: Alignment.centerRight, child: _buildNextButton(context)),
                  const SizedBox(height: 30),
                ],
              ),
            ),
          ),
          Align(
            alignment: Alignment.bottomCenter,
            child: CustomKeypad(onKeyPress: _handleKeypadInput, isOtpMode: true),
          ),
        ],
      ),
    );
  }
}

// =================================================================
// 5. PROFILE SETUP SCREEN (MODIFIED FOR ALPHANUMERIC KEYBOARD)
// =================================================================

class ProfileSetupScreen extends StatefulWidget {
  const ProfileSetupScreen({super.key});
  @override
  State<ProfileSetupScreen> createState() => _ProfileSetupScreenState();
}

class _ProfileSetupScreenState extends State<ProfileSetupScreen> {
  final TextEditingController _nameController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _nameController.addListener(() => setState(() {})); 
  }

  @override
  void dispose() {
    _nameController.removeListener(() => setState(() {}));
    _nameController.dispose();
    super.dispose();
  }

  void _onNextPressed() {
    if (_nameController.text.trim().isNotEmpty) {
      debugPrint('Name entered: ${_nameController.text}');
      Navigator.of(context).pushNamed('/pinSecurity');
    }
  }

  Widget _buildNameInputField({
    required TextEditingController controller,
    required String hintText,
    required IconData icon,
  }) {
    return TextField(
      controller: controller,
      keyboardType: TextInputType.name, 
      autofocus: true,
      style: const TextStyle(fontSize: 18),
      decoration: InputDecoration(
        hintText: hintText,
        hintStyle: const TextStyle(color: Colors.grey, fontSize: 18),
        contentPadding: const EdgeInsets.symmetric(vertical: 15),
        prefixIcon: Padding(padding: const EdgeInsets.only(right: 12.0), child: Icon(icon, color: kPrimaryBlue)),
        border: UnderlineInputBorder(borderSide: BorderSide(color: kPrimaryBlue, width: 1.5)),
        enabledBorder: UnderlineInputBorder(borderSide: BorderSide(color: kPrimaryBlue, width: 1.5)),
        focusedBorder: UnderlineInputBorder(borderSide: BorderSide(color: kPrimaryBlue, width: 2)),
      ),
    );
  }

  Widget _buildNextButton() {
    final bool isEnabled = _nameController.text.trim().isNotEmpty;
    return Container(
      width: 60, height: 60,
      decoration: BoxDecoration(
        color: isEnabled ? kSecondaryBlue : Colors.grey.shade400,
        shape: BoxShape.circle,
        boxShadow: isEnabled ? [BoxShadow(color: kSecondaryBlue.withOpacity(0.5), blurRadius: 10, offset: const Offset(0, 5))] : null,
      ),
      child: IconButton(icon: Icon(Icons.arrow_forward, color: isEnabled ? Colors.white : Colors.white), iconSize: 30, onPressed: isEnabled ? _onNextPressed : null),
    );
  }

  @override
  Widget build(BuildContext context) {
    const double headerHeightRatio = 0.30;
    final double profileCircleSize = 120;

    return Scaffold(
      resizeToAvoidBottomInset: true,
      body: Stack(
        children: [
          Positioned(
            top: 0, left: 0, right: 0,
            child: ClipPath(
              clipper: LoginHeaderClipper(),
              child: Container(height: MediaQuery.of(context).size.height * headerHeightRatio, color: kHeaderCurveBlue),
            ),
          ),
          Positioned(
            top: 0, left: 0, right: 0,
            child: Padding(
              padding: const EdgeInsets.only(top: 40, left: 20, right: 20, bottom: 0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Row(
                    children: [
                      BackButton(color: Colors.white, onPressed: () => Navigator.of(context).pop()),
                      const SizedBox(width: 8),
                      const Text('Register', style: TextStyle(color: Colors.white, fontSize: 32, fontWeight: FontWeight.w700)),
                    ],
                  ),
                  SizedBox(
                    height: 40,
                    child: ElevatedButton(
                      onPressed: () => Navigator.of(context).pushReplacementNamed('/login'),
                      style: ElevatedButton.styleFrom(backgroundColor: Colors.white, foregroundColor: kPrimaryBlue, padding: const EdgeInsets.symmetric(horizontal: 15), shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)), side: BorderSide.none),
                      child: const Text('Login', style: TextStyle(fontWeight: FontWeight.bold)),
                    ),
                  ),
                ],
              ),
            ),
          ),
          Positioned.fill(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 30.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  SizedBox(height: MediaQuery.of(context).size.height * headerHeightRatio - (profileCircleSize / 2)),
                  Center(
                    child: Stack(
                      children: [
                        Container(width: profileCircleSize, height: profileCircleSize, decoration: BoxDecoration(color: kProfileCircleBlue, shape: BoxShape.circle), child: const Icon(Icons.person, color: Colors.white, size: 60)),
                        Positioned(bottom: 0, right: 0, child: Container(width: 35, height: 35, decoration: BoxDecoration(color: kSecondaryBlue, shape: BoxShape.circle, border: Border.all(color: Colors.white, width: 2)), child: const Icon(Icons.edit, color: Colors.white, size: 18))),
                      ],
                    ),
                  ),
                  const SizedBox(height: 60),
                  _buildNameInputField(controller: _nameController, hintText: 'Your Name', icon: Icons.person_outline),
                  const SizedBox(height: 30),
                  Align(alignment: Alignment.centerRight, child: _buildNextButton()),
                  const SizedBox(height: 50),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// =================================================================
// 6. PIN SECURITY SCREEN
// =================================================================

class PinSecurityScreen extends StatefulWidget {
  const PinSecurityScreen({super.key});

  @override
  State<PinSecurityScreen> createState() => _PinSecurityScreenState();
}

enum PinState { setup, confirm }

class _PinSecurityScreenState extends State<PinSecurityScreen> {
  final int _pinLength = 4;
  String _currentPin = '';
  PinState _state = PinState.setup;
  String _initialPin = '';
  String _message = 'Protect your account with a secure PIN';
  bool _pinError = false;

  void _handleKeypadInput(String key) {
    setState(() {
      _pinError = false;
      if (key == 'DEL') {
        if (_currentPin.isNotEmpty) {
          _currentPin = _currentPin.substring(0, _currentPin.length - 1);
        }
      } else if (key != '.' && _currentPin.length < _pinLength) {
        _currentPin += key;

        if (_currentPin.length == _pinLength) {
          _processPin();
        }
      }
    });
  }

  void _processPin() {
    if (_state == PinState.setup) {
      _initialPin = _currentPin;
      _currentPin = '';
      _state = PinState.confirm;
      _message = 'Confirm your 4-digit PIN';
    } else if (_state == PinState.confirm) {
      if (_currentPin == _initialPin) {
        _message = 'PIN successfully set!';
        showDialog(
          context: context,
          barrierDismissible: false,
          builder: (BuildContext context) {
            return SuccessModal(
              onDismiss: () {
                Navigator.of(context).pushNamedAndRemoveUntil('/chatList', (route) => false);
              },
            );
          },
        );
      } else {
        _pinError = true;
        _message = 'PINs do not match. Please try again.';
        _currentPin = '';
        _initialPin = '';
        _state = PinState.setup;
      }
    }
  }

  void _onSkipPressed() { Navigator.of(context).pushNamedAndRemoveUntil('/chatList', (route) => false); }

  void _onContinuePressed() {
    if (_currentPin.length == _pinLength) {
      _processPin();
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    const double headerHeightRatio = 0.40;
    final double contentTop = screenHeight * headerHeightRatio * 0.5;
    final double keypadHeight = screenHeight * 0.35;
    final bool enableContinue = _currentPin.length == _pinLength;

    return Scaffold(
      body: Stack(
        children: [
          Positioned(
            top: 0, left: 0, right: 0,
            height: screenHeight * headerHeightRatio * 0.5,
            child: Container(color: kHeaderCurveBlue),
          ),
          Positioned(
            top: 50, left: 20, right: 20,
            child: Row(
              children: [
                BackButton(color: Colors.white, onPressed: () => Navigator.of(context).pop()),
                const SizedBox(width: 8),
                const Text('PIN Security', style: TextStyle(color: Colors.white, fontSize: 28, fontWeight: FontWeight.bold)),
              ],
            ),
          ),
          Positioned(
            top: contentTop, left: 0, right: 0, bottom: keypadHeight,
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 40.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const SizedBox(height: 30),
                  Text(_message, style: TextStyle(color: _pinError ? kErrorRed : Colors.grey.shade600, fontSize: 18)),
                  const SizedBox(height: 50),
                 PinInput(pinLength: _pinLength, currentPin: _currentPin),
                  const Spacer(),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      TextButton(onPressed: _onSkipPressed, style: TextButton.styleFrom(foregroundColor: kSecondaryBlue, padding: const EdgeInsets.symmetric(horizontal: 30)), child: const Text('Skip', style: TextStyle(fontSize: 18))),
                      ElevatedButton(
                        onPressed: enableContinue ? _onContinuePressed : null,
                        style: ElevatedButton.styleFrom(backgroundColor: kSecondaryBlue, foregroundColor: Colors.white, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(25)), padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 15), disabledBackgroundColor: Colors.grey),
                        child: const Text('Continue', style: TextStyle(fontSize: 18)),
                      ),
                    ],
                  ),
                  const SizedBox(height: 20),
                ],
              ),
            ),
          ),
          Align(
            alignment: Alignment.bottomCenter,
            child: CustomKeypad(onKeyPress: _handleKeypadInput, isOtpMode: true),
          ),
        ],
      ),
    );
  }
}

// =================================================================
// 7. CHAT LIST SCREEN (STATEFUL VERSION)
// =================================================================

class _ChatListScreenState extends State<ChatListScreen> {
  final List<ChatDataModel> _chats = [
    ChatDataModel(id: 'user_1', name: 'Alice Johnson', lastMessage: 'See you tomorrow at the meeting!', lastMessageTime: DateTime.now().subtract(const Duration(minutes: 5)), avatarUrl: 'https://placehold.co/50x50/FF5722/white?text=AJ', unreadCount: 2),
    ChatDataModel(id: 'group_1', name: 'Project Alpha Team', lastMessage: 'The document is ready for review.', lastMessageTime: DateTime.now().subtract(const Duration(hours: 1)), unreadCount: 5, isGroupChat: true),
    ChatDataModel(id: 'user_2', name: 'Bob Smith', lastMessage: 'Sounds good, I will handle that.', lastMessageTime: DateTime.now().subtract(const Duration(days: 1)), avatarUrl: 'https://placehold.co/50x50/4CAF50/white?text=BS', unreadCount: 0),
  ];

  void _navigateToChatRoom(ChatDataModel chat) {
    Navigator.of(context).pushNamed('/chatRoom', arguments: chat);
  }

  void _navigateToNewChatOrGroup() {
    Navigator.of(context).pushNamed('/newGroup');
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Chats'), backgroundColor: kPrimaryBlue, foregroundColor: Colors.white, elevation: 4.0, actions: [IconButton(icon: const Icon(Icons.search), onPressed: (){})]),
      body: ListView.builder(
        itemCount: _chats.length,
        itemBuilder: (context, index) {
          final chat = _chats[index];
          return ChatListItem(chat: chat, onTap: () => _navigateToChatRoom(chat));
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _navigateToNewChatOrGroup,
        backgroundColor: kSecondaryBlue, foregroundColor: Colors.white,
        child: const Icon(Icons.add_comment_outlined),
      ),
    );
  }
}

class ChatListScreen extends StatefulWidget {
  const ChatListScreen({super.key});
  @override
  State<ChatListScreen> createState() => _ChatListScreenState();
}


// =================================================================
// 8. CHAT ROOM SCREEN 
// =================================================================

class _ChatRoomScreenState extends State<ChatRoomScreen> {
  final TextEditingController _textController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  List<MessageModel> _messages = [];

  @override
  void initState() {
    super.initState();
    _loadMockMessages();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_scrollController.hasClients) {
        _scrollController.jumpTo(_scrollController.position.maxScrollExtent);
      }
    });
    _textController.addListener(() => setState(() {}));
  }

  @override
  void dispose() {
    _textController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  void _loadMockMessages() {
    setState(() {
      _messages = [
        MessageModel(id: 'm1', content: 'Hey ${widget.chat.name}, are you free to chat?', timestamp: DateTime.now().subtract(const Duration(minutes: 10)), isMe: false),
        MessageModel(id: 'm2', content: 'Yes! I just finished up.', timestamp: DateTime.now().subtract(const Duration(minutes: 8)), isMe: true),
        MessageModel(id: 'm3', content: widget.chat.lastMessage, timestamp: DateTime.now().subtract(const Duration(minutes: 5)), isMe: widget.chat.isGroupChat ? false : true),
      ];
    });
  }

  void _sendMessage() {
    if (_textController.text.trim().isNotEmpty) {
      setState(() {
        _messages.add(
          MessageModel(id: DateTime.now().toString(), content: _textController.text.trim(), timestamp: DateTime.now(), isMe: true),
        );
        _textController.clear();
      });
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
      Future.delayed(const Duration(seconds: 1), () { _simulateReply(); });
    }
  }

  void _simulateReply() {
    setState(() {
      _messages.add(MessageModel(id: DateTime.now().toString(), content: "Got it! Thanks for the update.", timestamp: DateTime.now(), isMe: false));
    });
    if (_scrollController.hasClients) {
       _scrollController.animateTo(_scrollController.position.maxScrollExtent, duration: const Duration(milliseconds: 300), curve: Curves.easeOut);
    }
  }
  
  Widget _buildMessageInput(BuildContext context) {
    final bool isSendButtonEnabled = _textController.text.trim().isNotEmpty;
    return Container(
      padding: const EdgeInsets.only(left: 10, right: 10, bottom: 10, top: 5),
      decoration: BoxDecoration(
        color: kBackgroundColor.withOpacity(0.95),
        border: Border(top: BorderSide(color: Colors.grey.shade200, width: 1)),
      ),
      child: Row(
        children: [
          IconButton(icon: const Icon(Icons.attachment, color: kPrimaryBlue), onPressed: () => debugPrint('Attachment feature not implemented.')),
          Expanded(
            child: TextField(
              controller: _textController,
              keyboardType: TextInputType.multiline,
              maxLines: 5, minLines: 1,
              cursorColor: kPrimaryBlue,
              decoration: InputDecoration(
                hintText: 'Message ${widget.chat.isGroupChat ? 'the group' : widget.chat.name}...',
                filled: true,
                fillColor: Colors.white,
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(25.0), borderSide: BorderSide.none),
                contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
              ),
              onSubmitted: (_) => _sendMessage(),
            ),
          ),
          const SizedBox(width: 8),
          Container(
            width: 45, height: 45,
            decoration: BoxDecoration(
              color: isSendButtonEnabled ? kSecondaryBlue : Colors.grey,
              shape: BoxShape.circle,
            ),
            child: IconButton(icon: const Icon(Icons.send, color: Colors.white), onPressed: isSendButtonEnabled ? _sendMessage : null),
          ),
        ],
      ),
    );
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.chat.name),
        backgroundColor: kPrimaryBlue, foregroundColor: Colors.white, elevation: 4.0,
        leading: IconButton(icon: const Icon(Icons.arrow_back), onPressed: () => Navigator.of(context).pop()),
        actions: [
          IconButton(icon: const Icon(Icons.call), onPressed: () => debugPrint('Call initiated with ${widget.chat.name}')),
          IconButton(icon: const Icon(Icons.more_vert), onPressed: () => debugPrint('More options for ${widget.chat.name}')),
        ],
      ),
      body: Column(
        children: [
          Expanded(
            child: ListView.builder(
              controller: _scrollController,
              padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
              itemCount: _messages.length,
              itemBuilder: (context, index) => ChatBubble(message: _messages[index]),
            ),
          ),
          _buildMessageInput(context),
        ],
      ),
    );
  }
}

class ChatRoomScreen extends StatefulWidget {
  final ChatDataModel chat;
  const ChatRoomScreen({super.key, required this.chat});
  @override
  State<ChatRoomScreen> createState() => _ChatRoomScreenState();
}

// =================================================================
// 9. NEW GROUP CREATION SCREEN
// =================================================================

class NewGroupScreen extends StatefulWidget {
  const NewGroupScreen({super.key});

  @override
  State<NewGroupScreen> createState() => _NewGroupScreenState();
}

class _NewGroupScreenState extends State<NewGroupScreen> {
  final TextEditingController _groupNameController = TextEditingController();
  final List<ContactModel> _mockContacts = [
    ContactModel(id: 'c1', name: 'Charlie Davis', phoneNumber: '+1 555 1234'),
    ContactModel(id: 'c2', name: 'Dana Evans', phoneNumber: '+44 123 5678'),
    ContactModel(id: 'c3', name: 'Ethan Fox', phoneNumber: '+91 999 8888'),
    ContactModel(id: 'c4', name: 'Fiona Green', phoneNumber: '+1 777 6666'),
    ContactModel(id: 'c5', name: 'George Hall', phoneNumber: '+44 987 1234'),
    ContactModel(id: 'c6', name: 'Holly King', phoneNumber: '+91 555 4321'),
  ];
  
  final List<ContactModel> _selectedMembers = [];

  @override
  void initState() {
    super.initState();
    _groupNameController.addListener(() => setState(() {}));
  }

  @override
  void dispose() {
    _groupNameController.dispose();
    super.dispose();
  }

  void _toggleMemberSelection(ContactModel contact) {
    setState(() {
      if (_selectedMembers.contains(contact)) {
        _selectedMembers.remove(contact);
      } else {
        _selectedMembers.add(contact);
      }
    });
  }

  void _createGroup() {
    final groupName = _groupNameController.text.trim();
    if (groupName.isNotEmpty && _selectedMembers.isNotEmpty) {
      debugPrint('Group Created: $groupName with ${_selectedMembers.length} members.');
      
      // Simulate creating the new group chat
      // In a real app, you would add this to your global chat list state.
      
      // Navigate back to the chat list
      Navigator.of(context).popUntil((route) => route.settings.name == '/chatList'); 
      
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter a group name and select at least one member.')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final isCreateButtonEnabled = _groupNameController.text.trim().isNotEmpty && _selectedMembers.isNotEmpty;

    return Scaffold(
      appBar: AppBar(
        title: const Text('New Group'),
        backgroundColor: kPrimaryBlue,
        foregroundColor: Colors.white,
        actions: [
          TextButton(
            onPressed: isCreateButtonEnabled ? _createGroup : null,
            child: Text(
              'Create',
              style: TextStyle(
                color: isCreateButtonEnabled ? Colors.white : Colors.white.withOpacity(0.5),
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          // 1. Group Name and Icon Setup Area
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Row(
              children: [
                Container(
                  width: 50, height: 50,
                  decoration: BoxDecoration(color: kProfileCircleBlue, shape: BoxShape.circle),
                  child: const Icon(Icons.group_add_outlined, color: kPrimaryBlue, size: 28),
                ),
                const SizedBox(width: 15),
                Expanded(
                  child: TextField(
                    controller: _groupNameController,
                    decoration: const InputDecoration(
                      hintText: 'Enter Group Name',
                      border: UnderlineInputBorder(),
                      focusedBorder: UnderlineInputBorder(borderSide: BorderSide(color: kPrimaryBlue)),
                    ),
                    textCapitalization: TextCapitalization.words,
                  ),
                ),
              ],
            ),
          ),
          
          const Divider(height: 1),

          // 2. Member Selection List Header
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Select Group Members (${_selectedMembers.length})',
                  style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: kPrimaryBlue),
                ),
                if (_selectedMembers.isNotEmpty)
                  const SizedBox(height: 10),
                
                // Horizontal list of selected members
                if (_selectedMembers.isNotEmpty)
                  SizedBox(
                    height: 50,
                    child: ListView.builder(
                      scrollDirection: Axis.horizontal,
                      itemCount: _selectedMembers.length,
                      itemBuilder: (context, index) {
                        final member = _selectedMembers[index];
                        return Padding(
                          padding: const EdgeInsets.only(right: 8.0),
                          child: Chip(
                            label: Text(member.name.split(' ').first),
                            deleteIcon: const Icon(Icons.close, size: 18),
                            onDeleted: () => _toggleMemberSelection(member),
                            backgroundColor: kLightBlueGradient,
                          ),
                        );
                      },
                    ),
                  ),
              ],
            ),
          ),

          // 3. Selectable Contacts List
          Expanded(
            child: ListView.builder(
              itemCount: _mockContacts.length,
              itemBuilder: (context, index) {
                final contact = _mockContacts[index];
                final isSelected = _selectedMembers.contains(contact);
                return ListTile(
                  leading: Container(
                    width: 40, height: 40,
                    decoration: BoxDecoration(color: kPrimaryBlue.withOpacity(0.1), shape: BoxShape.circle),
                    child: Center(child: Text(contact.name.substring(0, 1), style: const TextStyle(color: kPrimaryBlue))),
                  ),
                  title: Text(contact.name, style: const TextStyle(fontWeight: FontWeight.w500)),
                  subtitle: Text(contact.phoneNumber),
                  trailing: Checkbox(
                    value: isSelected,
                    onChanged: (bool? value) => _toggleMemberSelection(contact),
                    activeColor: kSecondaryBlue,
                  ),
                  onTap: () => _toggleMemberSelection(contact),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

// =================================================================
// >>> 10. CHAT HELPERS (Separated for clarity)
// =================================================================

// Chat Bubble Widget
class ChatBubble extends StatelessWidget {
  final MessageModel message;

  const ChatBubble({super.key, required this.message});

  @override
  Widget build(BuildContext context) {
    final isMe = message.isMe;
    final alignment = isMe ? Alignment.centerRight : Alignment.centerLeft;
    final color = isMe ? kSecondaryBlue : Colors.white;
    final textColor = isMe ? Colors.white : kPrimaryBlue;
    final borderRadius = BorderRadius.only(
      topLeft: const Radius.circular(12),
      topRight: const Radius.circular(12),
      bottomLeft: isMe ? const Radius.circular(12) : const Radius.circular(2),
      bottomRight: isMe ? const Radius.circular(2) : const Radius.circular(12),
    );

    return Align(
      alignment: alignment,
      child: Container(
        margin: const EdgeInsets.symmetric(vertical: 4.0, horizontal: 8.0),
        padding: const EdgeInsets.all(12.0),
        constraints: BoxConstraints(
          maxWidth: MediaQuery.of(context).size.width * 0.75,
        ),
        decoration: BoxDecoration(
          color: color,
          borderRadius: borderRadius,
          boxShadow: [
            BoxShadow(color: Colors.black.withOpacity(0.05), blurRadius: 5, offset: const Offset(0, 2)),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(message.content, style: TextStyle(color: textColor, fontSize: 15)),
            const SizedBox(height: 4),
            Text(
              '${message.timestamp.hour}:${message.timestamp.minute.toString().padLeft(2, '0')}',
              style: TextStyle(color: textColor.withOpacity(0.7), fontSize: 10),
            ),
          ],
        ),
      ),
    );
  }
}

// Chat List Item Widget
class ChatListItem extends StatelessWidget {
  final ChatDataModel chat;
  final VoidCallback onTap;

  const ChatListItem({
    super.key,
    required this.chat,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTap,
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 12.0, horizontal: 16.0),
        child: Row(
          children: [
            Stack(
              alignment: Alignment.bottomRight,
              children: [
                Container(
                  width: 50, height: 50,
                  decoration: BoxDecoration(
                    color: chat.isGroupChat ? kSecondaryBlue.withOpacity(0.2) : kPrimaryBlue.withOpacity(0.1),
                    shape: BoxShape.circle,
                  ),
                  child: Center(
                    child: Icon(chat.isGroupChat ? Icons.group : Icons.person, color: kPrimaryBlue, size: 28),
                  ),
                ),
                if (chat.unreadCount > 0)
                  Container(
                    padding: const EdgeInsets.all(4),
                    decoration: BoxDecoration(color: kErrorRed, shape: BoxShape.circle, border: Border.all(color: kBackgroundColor, width: 2)),
                    child: Text(chat.unreadCount.toString(), style: const TextStyle(color: Colors.white, fontSize: 10, fontWeight: FontWeight.bold)),
                  ),
              ],
            ),
            const SizedBox(width: 15),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(chat.name, style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600)),
                  const SizedBox(height: 4),
                  Text(chat.lastMessage, maxLines: 1, overflow: TextOverflow.ellipsis, style: TextStyle(fontSize: 14, color: Colors.grey.shade600)),
                ],
              ),
            ),
            const SizedBox(width: 10),
            Text(
              '${chat.lastMessageTime.hour}:${chat.lastMessageTime.minute.toString().padLeft(2, '0')}',
              style: TextStyle(fontSize: 12, color: chat.unreadCount > 0 ? kPrimaryBlue : Colors.grey),
            ),
          ],
        ),
      ),
    );
  }
}

// =================================================================
// >>> 11. REMAINING SHARED HELPERS
// =================================================================

// Custom Clipper for the Blue Curved Header (Used by all Auth screens)
class LoginHeaderClipper extends CustomClipper<Path> {
  @override
  Path getClip(Size size) {
    Path path = Path();
    path.lineTo(0, size.height - 50);
    path.quadraticBezierTo(
      size.width / 2, size.height, size.width, size.height - 50,
    );
    path.lineTo(size.width, 0);
    path.close();
    return path;
  }
  @override
  bool shouldReclip(CustomClipper<Path> oldClipper) => false;
}

// Custom Formatter for phone number spacing
class PhoneNumberFormatter extends TextInputFormatter {
  @override
  TextEditingValue formatEditUpdate(
    TextEditingValue oldValue,
    TextEditingValue newValue,
  ) {
    final int newTextLength = newValue.text.length;
    if (newTextLength == 0) { return newValue; }
    String cleanedText = newValue.text.replaceAll(RegExp(r'[^\d]'), '');
    final int cleanedLength = cleanedText.length;
    if (cleanedLength > 10) { cleanedText = cleanedText.substring(0, 10); }
    final StringBuffer newText = StringBuffer();
    for (int i = 0; i < cleanedLength; i++) {
      newText.write(cleanedText[i]);
      if (i == 1 || i == 5) { newText.write(' '); }
    }
    String formattedText = newText.toString();
    return TextEditingValue(text: formattedText, selection: TextSelection.collapsed(offset: formattedText.length));
  }
}

// Phone Input Field Helper
Widget _buildPhoneInputField({
  required TextEditingController controller,
  required String countryCode,
  required ValueChanged<String?> onCountryCodeChanged,
}) {
  const List<String> availableCodes = ['+44', '+1', '+91', '+86'];
  return TextField(
    controller: controller,
    keyboardType: TextInputType.none, 
    readOnly: true,
    inputFormatters: [FilteringTextInputFormatter.digitsOnly, PhoneNumberFormatter()],
    decoration: InputDecoration(
      hintText: '00 0000 0000', hintStyle: const TextStyle(color: Colors.grey), contentPadding: const EdgeInsets.symmetric(vertical: 15),
      prefixIcon: Padding(
        padding: const EdgeInsets.only(right: 12.0),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.flag, color: Colors.red), 
            const SizedBox(width: 8),
            DropdownButtonHideUnderline(
              child: DropdownButton<String>(
                value: countryCode,
                items: availableCodes.map((String code) => DropdownMenuItem<String>(value: code, child: Text(code, style: const TextStyle(color: Colors.black, fontSize: 16)))).toList(),
                onChanged: onCountryCodeChanged,
                icon: const Icon(Icons.arrow_drop_down, color: Colors.grey),
                style: const TextStyle(color: Colors.black),
              ),
            ),
            Container(height: 20, width: 1, margin: const EdgeInsets.symmetric(horizontal: 10), color: Colors.grey),
          ],
        ),
      ),
      border: const UnderlineInputBorder(borderSide: BorderSide(color: Colors.grey, width: 1.5)),
      enabledBorder: const UnderlineInputBorder(borderSide: BorderSide(color: Colors.grey, width: 1.5)),
      focusedBorder: const UnderlineInputBorder(borderSide: BorderSide(color: kPrimaryBlue, width: 2)),
    ),
  );
}

// Remember Me and Next Button Row (Reused)
Widget _buildRememberMeAndNextButton({
  required BuildContext context,
  required VoidCallback onNextPressed,
  required bool enableNextButton,
}) {
  return Padding(
    padding: const EdgeInsets.only(top: 10.0),
    child: Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Row(
          children: [
            SizedBox(width: 24, height: 24, child: Checkbox(value: true, onChanged: (bool? newValue) {}, activeColor: kSecondaryBlue, materialTapTargetSize: MaterialTapTargetSize.shrinkWrap)),
            const SizedBox(width: 4),
            const Text('Remember me'),
          ],
        ),
        Container(
          width: 50, height: 50,
          decoration: BoxDecoration(
            color: enableNextButton ? kSecondaryBlue : Colors.grey,
            shape: BoxShape.circle,
            boxShadow: enableNextButton ? [BoxShadow(color: kSecondaryBlue.withOpacity(0.5), blurRadius: 10, offset: const Offset(0, 5))] : null,
          ),
          child: IconButton(icon: const Icon(Icons.arrow_forward, color: Colors.white), onPressed: enableNextButton ? onNextPressed : null),
        ),
      ],
    ),
  );
}

// Custom Keypad Widget
class CustomKeypad extends StatelessWidget {
  final ValueSetter<String> onKeyPress;
  final bool isOtpMode;

  const CustomKeypad({super.key, required this.onKeyPress, this.isOtpMode = false});

  static const List<List<dynamic>> _keypadLayout = [
    ['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9'], ['.', '0', 'DEL']
  ];
  
  Widget _buildKey(BuildContext context, dynamic keyData, {bool isSpecial = false}) {
    final bool isDelete = keyData == 'DEL';
    final Color buttonColor = isDelete || keyData == '.' ? kKeypadSpecialKeyColor : kKeypadKeyColor;
    final bool isNumber = keyData is String && int.tryParse(keyData) != null;
    final Map<String, String> qwertyMap = {'1': '', '2': 'ABC', '3': 'DEF', '4': 'GHI', '5': 'JKL', '6': 'MNO', '7': 'PQRS', '8': 'TUV', '9': 'WXYZ', '0': '+', '.': ''};
    
    final Widget keyContent = isDelete
        ? const Icon(Icons.backspace_outlined, color: Colors.white, size: 24)
        : Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(keyData.toString(), style: const TextStyle(color: Colors.white, fontSize: 24, fontWeight: FontWeight.w400)),
              if (!isOtpMode && isNumber) Text(qwertyMap[keyData.toString()]!, style: const TextStyle(color: Colors.white70, fontSize: 10, letterSpacing: 0.5)),
            ],
          );

    return Expanded(
      child: Padding(
        padding: const EdgeInsets.all(8.0),
        child: InkWell(
          onTap: () => onKeyPress(keyData.toString()),
          borderRadius: BorderRadius.circular(10),
          child: Container(
            height: 50,
            decoration: BoxDecoration(color: buttonColor, borderRadius: BorderRadius.circular(10), boxShadow: const [BoxShadow(color: Colors.black26, offset: Offset(0, 2), blurRadius: 2)]),
            child: Center(child: keyContent),
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    final double keypadHeight = screenHeight * 0.35;
    return Container(
      height: keypadHeight,
      decoration: const BoxDecoration(color: kKeypadBackground, borderRadius: BorderRadius.only(topLeft: Radius.circular(20), topRight: Radius.circular(20))),
      padding: const EdgeInsets.all(8.0),
      child: Column(
        children: _keypadLayout.map((row) => Expanded(child: Row(mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: row.map((keyData) => _buildKey(context, keyData)).toList()))).toList(),
      ),
    );
  }
}

// PIN Input Field Helper
class PinInput extends StatelessWidget {
  final int pinLength;
  final String currentPin;

  const PinInput({super.key, required this.pinLength, required this.currentPin});

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: List.generate(pinLength, (index) {
        bool isFilled = index < currentPin.length;
        return Container(
          width: 50, height: 50, alignment: Alignment.center,
          decoration: BoxDecoration(
            border: Border(bottom: BorderSide(color: isFilled ? kPrimaryBlue : Colors.grey.shade400, width: 2.0)),
          ),
          child: Text(currentPin.length > index ? currentPin[index] : '', style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: kPrimaryBlue)),
        );
      }),
    );
  }
}

// Success Modal
class SuccessModal extends StatelessWidget {
  final VoidCallback onDismiss;

  const SuccessModal({super.key, required this.onDismiss});

  @override
  Widget build(BuildContext context) {
    Future.delayed(const Duration(seconds: 2), onDismiss);
    return AlertDialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20.0)),
      contentPadding: EdgeInsets.zero,
      content: Container(
        padding: const EdgeInsets.all(24.0), width: MediaQuery.of(context).size.width * 0.8,
        decoration: BoxDecoration(color: Colors.white, borderRadius: BorderRadius.circular(20.0)),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Align(alignment: Alignment.topRight, child: GestureDetector(onTap: onDismiss, child: const Icon(Icons.close, color: Colors.grey))),
            const Text('Congratulations!', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: Colors.black87)),
            const SizedBox(height: 20),
            Container(height: 150, width: 150, decoration: BoxDecoration(color: kHeaderCurveBlue.withOpacity(0.5), borderRadius: BorderRadius.circular(10)), child: const Center(child: Icon(Icons.check_circle_outline, size: 60, color: Colors.white))),
            const SizedBox(height: 20),
            const Text('Your account is now ready to use.', textAlign: TextAlign.center, style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
            const SizedBox(height: 5),
            Text('You will be redirected to the Home page shortly.', textAlign: TextAlign.center, style: TextStyle(fontSize: 14, color: Colors.grey.shade600)),
            const SizedBox(height: 20),
            SizedBox(width: 30, height: 30, child: CircularProgressIndicator(valueColor: AlwaysStoppedAnimation<Color>(kSecondaryBlue), strokeWidth: 3)),
            const SizedBox(height: 10),
          ],
        ),
      ),
    );
  }
}


// =================================================================
// >>> 3. AUTHENTICATION SCREENS
// =================================================================

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});
  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final TextEditingController _phoneController = TextEditingController();
  String _countryCode = '+44'; 

  @override
  void initState() {
    super.initState();
    _phoneController.addListener(_checkAutoAdvance);
  }

  @override
  void dispose() {
    _phoneController.removeListener(_checkAutoAdvance);
    _phoneController.dispose();
    super.dispose();
  }

  void _checkAutoAdvance() {
    final cleanedText = _phoneController.text.replaceAll(' ', '');
    if (cleanedText.length == 10) {
      if (mounted) {
        _phoneController.removeListener(_checkAutoAdvance);
        _navigateToOtp();
      }
    } else {
      setState(() {});
    }
  }

  void _navigateToOtp() {
    final phoneNumber = _phoneController.text;
    final fullNumber = '$_countryCode ${phoneNumber.replaceAll(' ', '')}';
    Navigator.of(context).pushNamed('/otp', arguments: fullNumber); 
  }

  void _handleKeypadInput(String key) {
    String currentText = _phoneController.text;
    String cleanedText = currentText.replaceAll(' ', '');

    if (key == 'DEL') {
      if (currentText.isNotEmpty) {
        String rawText = currentText.replaceAll(' ', '');
        if (rawText.isNotEmpty) {
          rawText = rawText.substring(0, rawText.length - 1);
          final formattedValue = PhoneNumberFormatter().formatEditUpdate(
            TextEditingValue(text: currentText),
            TextEditingValue(text: rawText.padRight(10, '0').substring(0, rawText.length)),
          );
          _phoneController.value = formattedValue.copyWith(
            text: formattedValue.text.trim(),
            selection: TextSelection.collapsed(offset: formattedValue.text.trim().length),
          );
        }
      }
    } else if (key != '.' && cleanedText.length < 10) {
      String newRawText = cleanedText + key;
      final formattedValue = PhoneNumberFormatter().formatEditUpdate(
        TextEditingValue(text: currentText),
        TextEditingValue(text: newRawText),
      );
      _phoneController.value = formattedValue.copyWith(
        text: formattedValue.text,
        selection: TextSelection.collapsed(offset: formattedValue.text.length),
      );
    }
  }

  void _onCountryCodeChanged(String? newCode) {
    if (newCode != null) {
      setState(() { _countryCode = newCode; });
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    const double headerHeightRatio = 0.40;
    final double headerHeight = screenHeight * headerHeightRatio;
    const double overlap = 20;
    final double contentTop = headerHeight - overlap;
    final double keypadHeight = screenHeight * 0.35; 
    final bool enableNextButton = _phoneController.text.replaceAll(' ', '').length == 10;

    return Scaffold(
      body: Stack(
        children: [
          _buildAuthHeader(context: context, title: 'Login', subTitle: 'Enter your \nmobile phone', actionButtonText: 'Register', onActionButtonPressed: () => Navigator.of(context).pushReplacementNamed('/register')),
          Positioned(
            top: contentTop, left: 0, right: 0, bottom: keypadHeight, 
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 30.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text('You will get a code via sms.', style: TextStyle(color: Colors.grey, fontSize: 16)),
                  const SizedBox(height: 20),
                  _buildPhoneInputField(controller: _phoneController, countryCode: _countryCode, onCountryCodeChanged: _onCountryCodeChanged), 
                  const SizedBox(height: 20),
                  _buildRememberMeAndNextButton(context: context, onNextPressed: _navigateToOtp, enableNextButton: enableNextButton),
                ],
              ),
            ),
          ),
          Align(
            alignment: Alignment.bottomCenter,
            child: CustomKeypad(onKeyPress: _handleKeypadInput, isOtpMode: false),
          ),
        ],
      ),
    );
  }
}

class OtpScreen extends StatefulWidget {
  final String fullPhoneNumber;
  const OtpScreen({super.key, required this.fullPhoneNumber});
  @override
  State<OtpScreen> createState() => _OtpScreenState();
}

class _OtpScreenState extends State<OtpScreen> {
  final int _start = 60; 
  late int _current = _start;
  late Timer _timer;
  bool _isResendActive = false;
  final int _otpLength = 4;

  late List<TextEditingController> _otpControllers;
  late List<FocusNode> _otpFocusNodes;
  String _errorMessage = ''; 

  @override
  void initState() {
    super.initState();
    _otpControllers = List.generate(_otpLength, (_) => TextEditingController());
    _otpFocusNodes = List.generate(_otpLength, (_) => FocusNode());
    _startTimer();
  }

  @override
  void dispose() {
    _timer.cancel();
    for (var controller in _otpControllers) { controller.dispose(); }
    for (var focusNode in _otpFocusNodes) { focusNode.dispose(); }
    super.dispose();
  }

  void _startTimer() {
    _isResendActive = false;
    _current = _start;
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_current == 0) {
        setState(() { _timer.cancel(); _isResendActive = true; });
      } else {
        setState(() { _current--; });
      }
    });
  }

  void _onResendCode() { setState(() { _errorMessage = ''; }); _startTimer(); }
  
  void _handleKeypadInput(String key) {
    if (key == 'DEL') {
      for (int i = _otpLength - 1; i >= 0; i--) {
        if (_otpControllers[i].text.isNotEmpty) {
          _otpControllers[i].clear();
          FocusScope.of(context).requestFocus(_otpFocusNodes[i]); 
          break;
        } else if (i > 0) {
          FocusScope.of(context).requestFocus(_otpFocusNodes[i - 1]);
          break;
        }
      }
    } else if (key != '.') {
      for (int i = 0; i < _otpLength; i++) {
        if (_otpControllers[i].text.isEmpty) {
          _otpControllers[i].text = key;
          
          if (i < _otpLength - 1) {
            FocusScope.of(context).requestFocus(_otpFocusNodes[i + 1]);
          } else {
            FocusScope.of(context).unfocus();
            _onNextPressed();
          }
          break;
        }
      }
    }
  }

  void _onNextPressed() {
    String enteredOtp = _otpControllers.map((c) => c.text).join();
    
    if (enteredOtp.length == _otpLength) { 
      setState(() { _errorMessage = ''; });
      Navigator.of(context).pushNamedAndRemoveUntil('/chatList', (route) => false);
      debugPrint('Login OTP Verified. Navigating to Chat List.');
    } else {
      setState(() { _errorMessage = 'Code invalid'; });
    }
  }

  Widget _buildOtpFields() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: List.generate(_otpLength, (index) {
        return SizedBox(
          width: 50,
          child: TextField(
            controller: _otpControllers[index],
            focusNode: _otpFocusNodes[index],
            textAlign: TextAlign.center,
            keyboardType: TextInputType.none, 
            readOnly: true, 
            maxLength: 1,
            style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            cursorColor: kPrimaryBlue,
            decoration: InputDecoration(
              counterText: '',
              contentPadding: const EdgeInsets.symmetric(vertical: 10),
              enabledBorder: UnderlineInputBorder(borderSide: BorderSide(color: Colors.grey.shade400, width: 2)),
              focusedBorder: const UnderlineInputBorder(borderSide: BorderSide(color: kPrimaryBlue, width: 2)),
              errorText: null,
            ),
            onChanged: (value) {}, 
          ),
        );
      }),
    );
  }

  Widget _buildTimerAndResend() {
    final String timerText = _current > 0 ? '00:${_current.toString().padLeft(2, '0')}' : '00:00';
    
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(timerText),
        const SizedBox(width: 8),
        GestureDetector(
          onTap: _isResendActive ? _onResendCode : null,
          child: Text('Resend Code', style: TextStyle(color: _isResendActive ? kPrimaryBlue : Colors.grey, fontWeight: FontWeight.w600, decoration: TextDecoration.underline)),
        ),
      ],
    );
  }

  Widget _buildNextButton(BuildContext context) {
    bool enableNext = _otpControllers.every((c) => c.text.isNotEmpty);
    
    return Container(
      width: 50, height: 50,
      decoration: BoxDecoration(
        color: enableNext ? kSecondaryBlue : Colors.grey,
        shape: BoxShape.circle,
        boxShadow: enableNext ? [BoxShadow(color: kSecondaryBlue.withOpacity(0.5), blurRadius: 10, offset: const Offset(0, 5))] : null,
      ),
      child: IconButton(icon: const Icon(Icons.arrow_forward, color: Colors.white), onPressed: enableNext ? _onNextPressed : null),
    );
  }

  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    const double headerHeightRatio = 0.40;
    final double headerHeight = screenHeight * headerHeightRatio;
    const double overlap = 20;
    final double contentTop = headerHeight - overlap;
    final double keypadHeight = screenHeight * 0.35;
    
    final subTitle = 'Enter OTP Code\nSent to: ${widget.fullPhoneNumber}';

    return Scaffold(
      body: Stack(
        children: [
          _buildAuthHeader(context: context, title: 'Login', subTitle: subTitle, actionButtonText: 'Register', onActionButtonPressed: () => Navigator.of(context).pushReplacementNamed('/register'), showBackButton: true),
          Positioned(
            top: contentTop, left: 0, right: 0, bottom: keypadHeight, 
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 30.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const SizedBox(height: 20),
                   _buildTimerAndResend(),
                  const SizedBox(height: 30),
                   _buildOtpFields(),
                   if (_errorMessage.isNotEmpty)
                      Padding(padding: const EdgeInsets.only(top: 8.0), child: Text(_errorMessage, style: const TextStyle(color: kErrorRed, fontWeight: FontWeight.w500))),
                   Align(alignment: Alignment.centerRight, child: _buildNextButton(context)),
                  const SizedBox(height: 30),
                ],
              ),
            ),
          ),
          Align(
            alignment: Alignment.bottomCenter,
            child: CustomKeypad(onKeyPress: _handleKeypadInput, isOtpMode: true),
          ),
        ],
      ),
    );
  }
}

class RegisterScreen extends StatefulWidget {
  const RegisterScreen({super.key});
  @override
  State<RegisterScreen> createState() => _RegisterScreenState();
}

class _RegisterScreenState extends State<RegisterScreen> {
  final TextEditingController _phoneController = TextEditingController();
  String _countryCode = '+44'; 

  @override
  void initState() {
    super.initState();
    _phoneController.addListener(_checkAutoAdvance);
  }

  @override
  void dispose() {
    _phoneController.removeListener(_checkAutoAdvance);
    _phoneController.dispose();
    super.dispose();
  }

  void _checkAutoAdvance() {
    final cleanedText = _phoneController.text.replaceAll(' ', '');
    if (cleanedText.length == 10) {
      if (mounted) {
        _phoneController.removeListener(_checkAutoAdvance);
        _navigateToOtp();
      }
    } else {
      setState(() {});
    }
  }

  void _navigateToOtp() {
    final phoneNumber = _phoneController.text;
    final fullNumber = '$_countryCode ${phoneNumber.replaceAll(' ', '')}';
    Navigator.of(context).pushNamed('/registerOtp', arguments: fullNumber); 
  }

  void _handleKeypadInput(String key) {
    String currentText = _phoneController.text;
    String cleanedText = currentText.replaceAll(' ', '');

    if (key == 'DEL') {
      if (currentText.isNotEmpty) {
        String rawText = currentText.replaceAll(' ', '');
        if (rawText.isNotEmpty) {
          rawText = rawText.substring(0, rawText.length - 1);
          final formattedValue = PhoneNumberFormatter().formatEditUpdate(
            TextEditingValue(text: currentText),
            TextEditingValue(text: rawText.padRight(10, '0').substring(0, rawText.length)),
          );
          _phoneController.value = formattedValue.copyWith(
            text: formattedValue.text.trim(),
            selection: TextSelection.collapsed(offset: formattedValue.text.trim().length),
          );
        }
      }
    } else if (key != '.' && cleanedText.length < 10) {
      String newRawText = cleanedText + key;
      
      final formattedValue = PhoneNumberFormatter().formatEditUpdate(
        TextEditingValue(text: currentText),
        TextEditingValue(text: newRawText),
      );

      _phoneController.value = formattedValue.copyWith(
        text: formattedValue.text,
        selection: TextSelection.collapsed(offset: formattedValue.text.length),
      );
    }
  }
  void _onCountryCodeChanged(String? newCode) {
    if (newCode != null) {
      setState(() { _countryCode = newCode; });
    }
  }
  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    const double headerHeightRatio = 0.40;
    final double headerHeight = screenHeight * headerHeightRatio;
    const double overlap = 20;
    final double contentTop = headerHeight - overlap;
    final double keypadHeight = screenHeight * 0.35;
    final bool enableNextButton = _phoneController.text.replaceAll(' ', '').length == 10;

    return Scaffold(
      body: Stack(
        children: [
          _buildAuthHeader(context: context, title: 'Register', subTitle: 'Enter your \nmobile phone', actionButtonText: 'Login', onActionButtonPressed: () => Navigator.of(context).pushReplacementNamed('/login')),
          Positioned(
            top: contentTop, left: 0, right: 0, bottom: keypadHeight,
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 30.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text('You will get a code via sms.', style: TextStyle(color: Colors.grey, fontSize: 16)),
                  const SizedBox(height: 20),
                  _buildPhoneInputField(controller: _phoneController, countryCode: _countryCode, onCountryCodeChanged: _onCountryCodeChanged), 
                  const SizedBox(height: 20),
                  _buildRememberMeAndNextButton(context: context, onNextPressed: _navigateToOtp, enableNextButton: enableNextButton),
                ],
              ),
            ),
          ),
          Align(
            alignment: Alignment.bottomCenter,
            child: CustomKeypad(onKeyPress: _handleKeypadInput, isOtpMode: false),
          ),
        ],
      ),
    );
  }
}

class RegisterOtpScreen extends StatefulWidget {
  final String fullPhoneNumber;
  const RegisterOtpScreen({super.key, required this.fullPhoneNumber});
  @override
  State<RegisterOtpScreen> createState() => _RegisterOtpScreenState();
}

class _RegisterOtpScreenState extends State<RegisterOtpScreen> {
  final int _start = 60;
  late int _current = _start;
  late Timer _timer;
  bool _isResendActive = false;
  final int _otpLength = 4; 

  late List<TextEditingController> _otpControllers;
  late List<FocusNode> _otpFocusNodes;
  String _errorMessage = ''; 

  @override
  void initState() {
    super.initState();
    _otpControllers = List.generate(_otpLength, (_) => TextEditingController());
    _otpFocusNodes = List.generate(_otpLength, (_) => FocusNode());
    _startTimer();
  }

  @override
  void dispose() {
    _timer.cancel();
    for (var controller in _otpControllers) { controller.dispose(); }
    for (var focusNode in _otpFocusNodes) { focusNode.dispose(); }
    super.dispose();
  }

  void _startTimer() {
    _isResendActive = false;
    _current = _start;
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_current == 0) {
        setState(() { _timer.cancel(); _isResendActive = true; });
      } else {
        setState(() { _current--; });
      }
    });
  }

  void _onResendCode() { setState(() { _errorMessage = ''; }); _startTimer(); }
  
  void _handleKeypadInput(String key) {
    if (key == 'DEL') {
      for (int i = _otpLength - 1; i >= 0; i--) {
        if (_otpControllers[i].text.isNotEmpty) {
          _otpControllers[i].clear();
          FocusScope.of(context).requestFocus(_otpFocusNodes[i]); 
          break;
        } else if (i > 0) {
          FocusScope.of(context).requestFocus(_otpFocusNodes[i - 1]);
          break;
        }
      }
    } else if (key != '.') {
      for (int i = 0; i < _otpLength; i++) {
        if (_otpControllers[i].text.isEmpty) {
          _otpControllers[i].text = key;
          
          if (i < _otpLength - 1) {
            FocusScope.of(context).requestFocus(_otpFocusNodes[i + 1]);
          } else {
            FocusScope.of(context).unfocus();
            _onNextPressed();
          }
          break;
        }
      }
    }
  }

  void _onNextPressed() {
    String enteredOtp = _otpControllers.map((c) => c.text).join();
    
    if (enteredOtp.length == _otpLength) { 
      setState(() { _errorMessage = ''; });
      Navigator.of(context).pushNamed('/profileSetup'); 
      debugPrint('Registration OTP Verified. Navigating to Profile Setup.');
    } else {
      setState(() { _errorMessage = 'Code invalid'; });
    }
  }

  Widget _buildOtpFields() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: List.generate(_otpLength, (index) {
        return SizedBox(
          width: 50,
          child: TextField(
            controller: _otpControllers[index],
            focusNode: _otpFocusNodes[index],
            textAlign: TextAlign.center,
            keyboardType: TextInputType.none, 
            readOnly: true, 
            maxLength: 1,
            style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            cursorColor: kPrimaryBlue,
            decoration: InputDecoration(
              counterText: '',
              contentPadding: const EdgeInsets.symmetric(vertical: 10),
              enabledBorder: UnderlineInputBorder(borderSide: BorderSide(color: Colors.grey.shade400, width: 2)),
              focusedBorder: const UnderlineInputBorder(borderSide: BorderSide(color: kPrimaryBlue, width: 2)),
              errorText: null,
            ),
            onChanged: (value) {},
          ),
        );
      }),
    );
  }

  Widget _buildTimerAndResend() {
    final String timerText = _current > 0 ? '00:${_current.toString().padLeft(2, '0')}' : '00:00';
    
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(timerText),
        const SizedBox(width: 8),
        GestureDetector(
          onTap: _isResendActive ? _onResendCode : null,
          child: Text('Resend Code', style: TextStyle(color: _isResendActive ? kPrimaryBlue : Colors.grey, fontWeight: FontWeight.w600, decoration: TextDecoration.underline)),
        ),
      ],
    );
  }

  Widget _buildNextButton(BuildContext context) {
    bool enableNext = _otpControllers.every((c) => c.text.isNotEmpty);
    
    return Container(
      width: 50, height: 50,
      decoration: BoxDecoration(
        color: enableNext ? kSecondaryBlue : Colors.grey,
        shape: BoxShape.circle,
        boxShadow: enableNext ? [BoxShadow(color: kSecondaryBlue.withOpacity(0.5), blurRadius: 10, offset: const Offset(0, 5))] : null,
      ),
      child: IconButton(icon: const Icon(Icons.arrow_forward, color: Colors.white), onPressed: enableNext ? _onNextPressed : null),
    );
  }

  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    const double headerHeightRatio = 0.40;
    final double headerHeight = screenHeight * headerHeightRatio;
    const double overlap = 20;
    final double contentTop = headerHeight - overlap;
    final double keypadHeight = screenHeight * 0.35;
    
    final subTitle = 'Enter OTP Code\nSent to: ${widget.fullPhoneNumber}';

    return Scaffold(
      body: Stack(
        children: [
          _buildAuthHeader(context: context, title: 'Register', subTitle: subTitle, actionButtonText: 'Login', onActionButtonPressed: () => Navigator.of(context).pushReplacementNamed('/login'), showBackButton: true),
          Positioned(
            top: contentTop, left: 0, right: 0, bottom: keypadHeight, 
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 30.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const SizedBox(height: 20),
                   _buildTimerAndResend(),
                  const SizedBox(height: 30),
                   _buildOtpFields(),
                   if (_errorMessage.isNotEmpty)
                      Padding(padding: const EdgeInsets.only(top: 8.0), child: Text(_errorMessage, style: const TextStyle(color: kErrorRed, fontWeight: FontWeight.w500))),
                   Align(alignment: Alignment.centerRight, child: _buildNextButton(context)),
                  const SizedBox(height: 30),
                ],
              ),
            ),
          ),
          Align(
            alignment: Alignment.bottomCenter,
            child: CustomKeypad(onKeyPress: _handleKeypadInput, isOtpMode: true),
          ),
        ],
      ),
    );
  }
}

// =================================================================
// 5. PROFILE SETUP SCREEN (MODIFIED FOR ALPHANUMERIC KEYBOARD)
// =================================================================

class ProfileSetupScreen extends StatefulWidget {
  const ProfileSetupScreen({super.key});
  @override
  State<ProfileSetupScreen> createState() => _ProfileSetupScreenState();
}

class _ProfileSetupScreenState extends State<ProfileSetupScreen> {
  final TextEditingController _nameController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _nameController.addListener(() => setState(() {})); 
  }

  @override
  void dispose() {
    _nameController.removeListener(() => setState(() {}));
    _nameController.dispose();
    super.dispose();
  }

  void _onNextPressed() {
    if (_nameController.text.trim().isNotEmpty) {
      debugPrint('Name entered: ${_nameController.text}');
      Navigator.of(context).pushNamed('/pinSecurity');
    }
  }

  Widget _buildNameInputField({
    required TextEditingController controller,
    required String hintText,
    required IconData icon,
  }) {
    return TextField(
      controller: controller,
      keyboardType: TextInputType.name, 
      autofocus: true,
      style: const TextStyle(fontSize: 18),
      decoration: InputDecoration(
        hintText: hintText,
        hintStyle: const TextStyle(color: Colors.grey, fontSize: 18),
        contentPadding: const EdgeInsets.symmetric(vertical: 15),
        prefixIcon: Padding(padding: const EdgeInsets.only(right: 12.0), child: Icon(icon, color: kPrimaryBlue)),
        border: UnderlineInputBorder(borderSide: BorderSide(color: kPrimaryBlue, width: 1.5)),
        enabledBorder: UnderlineInputBorder(borderSide: BorderSide(color: kPrimaryBlue, width: 1.5)),
        focusedBorder: UnderlineInputBorder(borderSide: BorderSide(color: kPrimaryBlue, width: 2)),
      ),
    );
  }

  Widget _buildNextButton() {
    final bool isEnabled = _nameController.text.trim().isNotEmpty;
    return Container(
      width: 60, height: 60,
      decoration: BoxDecoration(
        color: isEnabled ? kSecondaryBlue : Colors.grey.shade400,
        shape: BoxShape.circle,
        boxShadow: isEnabled ? [BoxShadow(color: kSecondaryBlue.withOpacity(0.5), blurRadius: 10, offset: const Offset(0, 5))] : null,
      ),
      child: IconButton(icon: Icon(Icons.arrow_forward, color: isEnabled ? Colors.white : Colors.white), iconSize: 30, onPressed: isEnabled ? _onNextPressed : null),
    );
  }

  @override
  Widget build(BuildContext context) {
    const double headerHeightRatio = 0.30;
    final double profileCircleSize = 120;

    return Scaffold(
      resizeToAvoidBottomInset: true,
      body: Stack(
        children: [
          Positioned(
            top: 0, left: 0, right: 0,
            child: ClipPath(
              clipper: LoginHeaderClipper(),
              child: Container(height: MediaQuery.of(context).size.height * headerHeightRatio, color: kHeaderCurveBlue),
            ),
          ),
          Positioned(
            top: 0, left: 0, right: 0,
            child: Padding(
              padding: const EdgeInsets.only(top: 40, left: 20, right: 20, bottom: 0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Row(
                    children: [
                      BackButton(color: Colors.white, onPressed: () => Navigator.of(context).pop()),
                      const SizedBox(width: 8),
                      const Text('Register', style: TextStyle(color: Colors.white, fontSize: 32, fontWeight: FontWeight.w700)),
                    ],
                  ),
                  SizedBox(
                    height: 40,
                    child: ElevatedButton(
                      onPressed: () => Navigator.of(context).pushReplacementNamed('/login'),
                      style: ElevatedButton.styleFrom(backgroundColor: Colors.white, foregroundColor: kPrimaryBlue, padding: const EdgeInsets.symmetric(horizontal: 15), shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)), side: BorderSide.none),
                      child: const Text('Login', style: TextStyle(fontWeight: FontWeight.bold)),
                    ),
                  ),
                ],
              ),
            ),
          ),
          Positioned.fill(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 30.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  SizedBox(height: MediaQuery.of(context).size.height * headerHeightRatio - (profileCircleSize / 2)),
                  Center(
                    child: Stack(
                      children: [
                        Container(width: profileCircleSize, height: profileCircleSize, decoration: BoxDecoration(color: kProfileCircleBlue, shape: BoxShape.circle), child: const Icon(Icons.person, color: Colors.white, size: 60)),
                        Positioned(bottom: 0, right: 0, child: Container(width: 35, height: 35, decoration: BoxDecoration(color: kSecondaryBlue, shape: BoxShape.circle, border: Border.all(color: Colors.white, width: 2)), child: const Icon(Icons.edit, color: Colors.white, size: 18))),
                      ],
                    ),
                  ),
                  const SizedBox(height: 60),
                  _buildNameInputField(controller: _nameController, hintText: 'Your Name', icon: Icons.person_outline),
                  const SizedBox(height: 30),
                  Align(alignment: Alignment.centerRight, child: _buildNextButton()),
                  const SizedBox(height: 50),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// =================================================================
// 6. PIN SECURITY SCREEN
// =================================================================

class PinSecurityScreen extends StatefulWidget {
  const PinSecurityScreen({super.key});

  @override
  State<PinSecurityScreen> createState() => _PinSecurityScreenState();
}

enum PinState { setup, confirm }

class _PinSecurityScreenState extends State<PinSecurityScreen> {
  final int _pinLength = 4;
  String _currentPin = '';
  PinState _state = PinState.setup;
  String _initialPin = '';
  String _message = 'Protect your account with a secure PIN';
  bool _pinError = false;

  void _handleKeypadInput(String key) {
    setState(() {
      _pinError = false;
      if (key == 'DEL') {
        if (_currentPin.isNotEmpty) {
          _currentPin = _currentPin.substring(0, _currentPin.length - 1);
        }
      } else if (key != '.' && _currentPin.length < _pinLength) {
        _currentPin += key;

        if (_currentPin.length == _pinLength) {
          _processPin();
        }
      }
    });
  }

  void _processPin() {
    if (_state == PinState.setup) {
      _initialPin = _currentPin;
      _currentPin = '';
      _state = PinState.confirm;
      _message = 'Confirm your 4-digit PIN';
    } else if (_state == PinState.confirm) {
      if (_currentPin == _initialPin) {
        _message = 'PIN successfully set!';
        showDialog(
          context: context,
          barrierDismissible: false,
          builder: (BuildContext context) {
            return SuccessModal(
              onDismiss: () {
                Navigator.of(context).pushNamedAndRemoveUntil('/chatList', (route) => false);
              },
            );
          },
        );
      } else {
        _pinError = true;
        _message = 'PINs do not match. Please try again.';
        _currentPin = '';
        _initialPin = '';
        _state = PinState.setup;
      }
    }
  }

  void _onSkipPressed() { Navigator.of(context).pushNamedAndRemoveUntil('/chatList', (route) => false); }

  void _onContinuePressed() {
    if (_currentPin.length == _pinLength) {
      _processPin();
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    const double headerHeightRatio = 0.40;
    final double contentTop = screenHeight * headerHeightRatio * 0.5;
    final double keypadHeight = screenHeight * 0.35;
    final bool enableContinue = _currentPin.length == _pinLength;

    return Scaffold(
      body: Stack(
        children: [
          Positioned(
            top: 0, left: 0, right: 0,
            height: screenHeight * headerHeightRatio * 0.5,
            child: Container(color: kHeaderCurveBlue),
          ),
          Positioned(
            top: 50, left: 20, right: 20,
            child: Row(
              children: [
                BackButton(color: Colors.white, onPressed: () => Navigator.of(context).pop()),
                const SizedBox(width: 8),
                const Text('PIN Security', style: TextStyle(color: Colors.white, fontSize: 28, fontWeight: FontWeight.bold)),
              ],
            ),
          ),
          Positioned(
            top: contentTop, left: 0, right: 0, bottom: keypadHeight,
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 40.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const SizedBox(height: 30),
                  Text(_message, style: TextStyle(color: _pinError ? kErrorRed : Colors.grey.shade600, fontSize: 18)),
                  const SizedBox(height: 50),
                 PinInput(pinLength: _pinLength, currentPin: _currentPin),
                  const Spacer(),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      TextButton(onPressed: _onSkipPressed, style: TextButton.styleFrom(foregroundColor: kSecondaryBlue, padding: const EdgeInsets.symmetric(horizontal: 30)), child: const Text('Skip', style: TextStyle(fontSize: 18))),
                      ElevatedButton(
                        onPressed: enableContinue ? _onContinuePressed : null,
                        style: ElevatedButton.styleFrom(backgroundColor: kSecondaryBlue, foregroundColor: Colors.white, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(25)), padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 15), disabledBackgroundColor: Colors.grey),
                        child: const Text('Continue', style: TextStyle(fontSize: 18)),
                      ),
                    ],
                  ),
                  const SizedBox(height: 20),
                ],
              ),
            ),
          ),
          Align(
            alignment: Alignment.bottomCenter,
            child: CustomKeypad(onKeyPress: _handleKeypadInput, isOtpMode: true),
          ),
        ],
      ),
    );
  }
}

// =================================================================
// 7. CHAT LIST SCREEN (STATEFUL VERSION)
// =================================================================

class _ChatListScreenState extends State<ChatListScreen> {
  final List<ChatDataModel> _chats = [
    ChatDataModel(id: 'user_1', name: 'Alice Johnson', lastMessage: 'See you tomorrow at the meeting!', lastMessageTime: DateTime.now().subtract(const Duration(minutes: 5)), avatarUrl: 'https://placehold.co/50x50/FF5722/white?text=AJ', unreadCount: 2),
    ChatDataModel(id: 'group_1', name: 'Project Alpha Team', lastMessage: 'The document is ready for review.', lastMessageTime: DateTime.now().subtract(const Duration(hours: 1)), unreadCount: 5, isGroupChat: true),
    ChatDataModel(id: 'user_2', name: 'Bob Smith', lastMessage: 'Sounds good, I will handle that.', lastMessageTime: DateTime.now().subtract(const Duration(days: 1)), avatarUrl: 'https://placehold.co/50x50/4CAF50/white?text=BS', unreadCount: 0),
  ];

  void _navigateToChatRoom(ChatDataModel chat) {
    Navigator.of(context).pushNamed('/chatRoom', arguments: chat);
  }

  void _navigateToNewChatOrGroup() {
    Navigator.of(context).pushNamed('/newGroup');
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Chats'), backgroundColor: kPrimaryBlue, foregroundColor: Colors.white, elevation: 4.0, actions: [IconButton(icon: const Icon(Icons.search), onPressed: (){})]),
      body: ListView.builder(
        itemCount: _chats.length,
        itemBuilder: (context, index) {
          final chat = _chats[index];
          return ChatListItem(chat: chat, onTap: () => _navigateToChatRoom(chat));
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _navigateToNewChatOrGroup,
        backgroundColor: kSecondaryBlue, foregroundColor: Colors.white,
        child: const Icon(Icons.add_comment_outlined),
      ),
    );
  }
}

class ChatListScreen extends StatefulWidget {
  const ChatListScreen({super.key});
  @override
  State<ChatListScreen> createState() => _ChatListScreenState();
}


// =================================================================
// 8. CHAT ROOM SCREEN 
// =================================================================

class _ChatRoomScreenState extends State<ChatRoomScreen> {
  final TextEditingController _textController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  List<MessageModel> _messages = [];

  @override
  void initState() {
    super.initState();
    _loadMockMessages();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_scrollController.hasClients) {
        _scrollController.jumpTo(_scrollController.position.maxScrollExtent);
      }
    });
    _textController.addListener(() => setState(() {}));
  }

  @override
  void dispose() {
    _textController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  void _loadMockMessages() {
    setState(() {
      _messages = [
        MessageModel(id: 'm1', content: 'Hey ${widget.chat.name}, are you free to chat?', timestamp: DateTime.now().subtract(const Duration(minutes: 10)), isMe: false),
        MessageModel(id: 'm2', content: 'Yes! I just finished up.', timestamp: DateTime.now().subtract(const Duration(minutes: 8)), isMe: true),
        MessageModel(id: 'm3', content: widget.chat.lastMessage, timestamp: DateTime.now().subtract(const Duration(minutes: 5)), isMe: widget.chat.isGroupChat ? false : true),
      ];
    });
  }

  void _sendMessage() {
    if (_textController.text.trim().isNotEmpty) {
      setState(() {
        _messages.add(
          MessageModel(id: DateTime.now().toString(), content: _textController.text.trim(), timestamp: DateTime.now(), isMe: true),
        );
        _textController.clear();
      });
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
      Future.delayed(const Duration(seconds: 1), () { _simulateReply(); });
    }
  }

  void _simulateReply() {
    setState(() {
      _messages.add(MessageModel(id: DateTime.now().toString(), content: "Got it! Thanks for the update.", timestamp: DateTime.now(), isMe: false));
    });
    if (_scrollController.hasClients) {
       _scrollController.animateTo(_scrollController.position.maxScrollExtent, duration: const Duration(milliseconds: 300), curve: Curves.easeOut);
    }
  }
  
  Widget _buildMessageInput(BuildContext context) {
    final bool isSendButtonEnabled = _textController.text.trim().isNotEmpty;
    return Container(
      padding: const EdgeInsets.only(left: 10, right: 10, bottom: 10, top: 5),
      decoration: BoxDecoration(
        color: kBackgroundColor.withOpacity(0.95),
        border: Border(top: BorderSide(color: Colors.grey.shade200, width: 1)),
      ),
      child: Row(
        children: [
          IconButton(icon: const Icon(Icons.attachment, color: kPrimaryBlue), onPressed: () => debugPrint('Attachment feature not implemented.')),
          Expanded(
            child: TextField(
              controller: _textController,
              keyboardType: TextInputType.multiline,
              maxLines: 5, minLines: 1,
              cursorColor: kPrimaryBlue,
              decoration: InputDecoration(
                hintText: 'Message ${widget.chat.isGroupChat ? 'the group' : widget.chat.name}...',
                filled: true,
                fillColor: Colors.white,
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(25.0), borderSide: BorderSide.none),
                contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
              ),
              onSubmitted: (_) => _sendMessage(),
            ),
          ),
          const SizedBox(width: 8),
          Container(
            width: 45, height: 45,
            decoration: BoxDecoration(
              color: isSendButtonEnabled ? kSecondaryBlue : Colors.grey,
              shape: BoxShape.circle,
            ),
            child: IconButton(icon: const Icon(Icons.send, color: Colors.white), onPressed: isSendButtonEnabled ? _sendMessage : null),
          ),
        ],
      ),
    );
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.chat.name),
        backgroundColor: kPrimaryBlue, foregroundColor: Colors.white, elevation: 4.0,
        leading: IconButton(icon: const Icon(Icons.arrow_back), onPressed: () => Navigator.of(context).pop()),
        actions: [
          IconButton(icon: const Icon(Icons.call), onPressed: () => debugPrint('Call initiated with ${widget.chat.name}')),
          IconButton(icon: const Icon(Icons.more_vert), onPressed: () => debugPrint('More options for ${widget.chat.name}')),
        ],
      ),
      body: Column(
        children: [
          Expanded(
            child: ListView.builder(
              controller: _scrollController,
              padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
              itemCount: _messages.length,
              itemBuilder: (context, index) => ChatBubble(message: _messages[index]),
            ),
          ),
          _buildMessageInput(context),
        ],
      ),
    );
  }
}

class ChatRoomScreen extends StatefulWidget {
  final ChatDataModel chat;
  const ChatRoomScreen({super.key, required this.chat});
  @override
  State<ChatRoomScreen> createState() => _ChatRoomScreenState();
}

// =================================================================
// 9. NEW GROUP CREATION SCREEN
// =================================================================

class NewGroupScreen extends StatefulWidget {
  const NewGroupScreen({super.key});

  @override
  State<NewGroupScreen> createState() => _NewGroupScreenState();
}

class _NewGroupScreenState extends State<NewGroupScreen> {
  final TextEditingController _groupNameController = TextEditingController();
  final List<ContactModel> _mockContacts = [
    ContactModel(id: 'c1', name: 'Charlie Davis', phoneNumber: '+1 555 1234'),
    ContactModel(id: 'c2', name: 'Dana Evans', phoneNumber: '+44 123 5678'),
    ContactModel(id: 'c3', name: 'Ethan Fox', phoneNumber: '+91 999 8888'),
    ContactModel(id: 'c4', name: 'Fiona Green', phoneNumber: '+1 777 6666'),
    ContactModel(id: 'c5', name: 'George Hall', phoneNumber: '+44 987 1234'),
    ContactModel(id: 'c6', name: 'Holly King', phoneNumber: '+91 555 4321'),
  ];
  
  final List<ContactModel> _selectedMembers = [];

  @override
  void initState() {
    super.initState();
    _groupNameController.addListener(() => setState(() {}));
  }

  @override
  void dispose() {
    _groupNameController.dispose();
    super.dispose();
  }

  void _toggleMemberSelection(ContactModel contact) {
    setState(() {
      if (_selectedMembers.contains(contact)) {
        _selectedMembers.remove(contact);
      } else {
        _selectedMembers.add(contact);
      }
    });
  }

  void _createGroup() {
    final groupName = _groupNameController.text.trim();
    if (groupName.isNotEmpty && _selectedMembers.isNotEmpty) {
      debugPrint('Group Created: $groupName with ${_selectedMembers.length} members.');
      
      // Simulate creating the new group chat
      
      // Navigate back to the chat list
      Navigator.of(context).popUntil((route) => route.settings.name == '/chatList'); 
      
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter a group name and select at least one member.')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final isCreateButtonEnabled = _groupNameController.text.trim().isNotEmpty && _selectedMembers.isNotEmpty;

    return Scaffold(
      appBar: AppBar(
        title: const Text('New Group'),
        backgroundColor: kPrimaryBlue,
        foregroundColor: Colors.white,
        actions: [
          TextButton(
            onPressed: isCreateButtonEnabled ? _createGroup : null,
            child: Text(
              'Create',
              style: TextStyle(
                color: isCreateButtonEnabled ? Colors.white : Colors.white.withOpacity(0.5),
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          // 1. Group Name and Icon Setup Area
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Row(
              children: [
                Container(
                  width: 50, height: 50,
                  decoration: BoxDecoration(color: kProfileCircleBlue, shape: BoxShape.circle),
                  child: const Icon(Icons.group_add_outlined, color: kPrimaryBlue, size: 28),
                ),
                const SizedBox(width: 15),
                Expanded(
                  child: TextField(
                    controller: _groupNameController,
                    decoration: const InputDecoration(
                      hintText: 'Enter Group Name',
                      border: UnderlineInputBorder(),
                      focusedBorder: UnderlineInputBorder(borderSide: BorderSide(color: kPrimaryBlue)),
                    ),
                    textCapitalization: TextCapitalization.words,
                  ),
                ),
              ],
            ),
          ),
          
          const Divider(height: 1),

          // 2. Member Selection List Header
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Select Group Members (${_selectedMembers.length})',
                  style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: kPrimaryBlue),
                ),
                if (_selectedMembers.isNotEmpty)
                  const SizedBox(height: 10),
                
                // Horizontal list of selected members
                if (_selectedMembers.isNotEmpty)
                  SizedBox(
                    height: 50,
                    child: ListView.builder(
                      scrollDirection: Axis.horizontal,
                      itemCount: _selectedMembers.length,
                      itemBuilder: (context, index) {
                        final member = _selectedMembers[index];
                        return Padding(
                          padding: const EdgeInsets.only(right: 8.0),
                          child: Chip(
                            label: Text(member.name.split(' ').first),
                            deleteIcon: const Icon(Icons.close, size: 18),
                            onDeleted: () => _toggleMemberSelection(member),
                            backgroundColor: kLightBlueGradient,
                          ),
                        );
                      },
                    ),
                  ),
              ],
            ),
          ),

          // 3. Selectable Contacts List
          Expanded(
            child: ListView.builder(
              itemCount: _mockContacts.length,
              itemBuilder: (context, index) {
                final contact = _mockContacts[index];
                final isSelected = _selectedMembers.contains(contact);
                return ListTile(
                  leading: Container(
                    width: 40, height: 40,
                    decoration: BoxDecoration(color: kPrimaryBlue.withOpacity(0.1), shape: BoxShape.circle),
                    child: Center(child: Text(contact.name.substring(0, 1), style: const TextStyle(color: kPrimaryBlue))),
                  ),
                  title: Text(contact.name, style: const TextStyle(fontWeight: FontWeight.w500)),
                  subtitle: Text(contact.phoneNumber),
                  trailing: Checkbox(
                    value: isSelected,
                    onChanged: (bool? value) => _toggleMemberSelection(contact),
                    activeColor: kSecondaryBlue,
                  ),
                  onTap: () => _toggleMemberSelection(contact),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}